<!DOCTYPE html>
<html lang="zh-cn">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="gpt-image-1 API 图像生成调用工具（需自备 API KEY）">
  <meta name="keywords" content="gpt-image-1, 图像生成, API, 工具">
  <title>gpt-image-1 API 图像生成调用工具 - 天天发蛋糕的工具箱</title>
  <link rel="stylesheet" href="../../assets/css/styles.css">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-HYJXFSRHF5"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-HYJXFSRHF5');
  </script>
</head>

<body>
  <!-- 模板页头 -->
  <header class="site-header">
    <div class="container">
      <div class="site-title">
        <a href="/" class="site-title-link">
          <span class="site-title">天天发蛋糕的工具箱</span>
        </a>
      </div>
      <label for="menu-toggle-checkbox" class="menu-toggle" aria-label="打开菜单">☰</label>
      <nav class="nav-menu">
        <ul class="nav-list">
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" aria-haspopup="true" aria-expanded="false">工具</a>
            <ul class="dropdown-menu">
              <li><a href="/tools/yu-gi-oh-probability-calculator/" class="dropdown-item">游戏王概率计算器</a></li>
              <li><a href="/tools/card-translate/" class="dropdown-item">游戏王卡牌日中对照文本生成器</a></li>
              <li><a href="/tools/webp-avif-2-jpg-png/" class="dropdown-item">AVIF/WebP转JPG/PNG</a></li>
              <li><a href="https://chromewebstore.google.com/detail/kmnmkpgmneeokldcmfcgjppgpcfecoed"
                  class="dropdown-item">恢复关闭的标签页</a></li>
            </ul>
          </li>
        </ul>
      </nav>
    </div>
    <input type="checkbox" id="menu-toggle-checkbox" hidden>
    <div class="drawer">
      <div class="container">
        <label for="menu-toggle-checkbox" class="menu-toggle close-menu" aria-label="关闭菜单">×</label>
      </div>
      <nav class="drawer-menu">
        <ul class="drawer-list">
          <li class="drawer-item">
            <a href="#" class="drawer-link">工具</a>
            <ul class="drawer-submenu">
              <li><a href="/tools/yu-gi-oh-probability-calculator/" class="drawer-subitem">游戏王概率计算器</a></li>
              <li><a href="/tools/card-translate/" class="drawer-subitem">游戏王卡牌日中对照文本生成器</a></li>
              <li><a href="/tools/webp-avif-2-jpg-png/" class="drawer-subitem">AVIF/WebP转JPG/PNG</a></li>
              <li><a href="https://chromewebstore.google.com/detail/kmnmkpgmneeokldcmfcgjppgpcfecoed"
                  class="drawer-subitem">恢复关闭的标签页</a></li>
            </ul>
          </li>
        </ul>
      </nav>
    </div>
    <label for="menu-toggle-checkbox" class="drawer-overlay"></label>
  </header>

  <!-- 主内容区域 -->
  <main class="container">
    <h1 class="mt-0 mb-3">gpt-image-1 API 图像生成调用工具</h1>
    <div class="card card--elevated">
      <div class="form-group mt-2">
        <label for="apiKey">API Key</label>
        <input type="text" id="apiKey" placeholder="请输入你的 API Key（请自备）" name="apiKey" autocomplete="on"
          class="form-control">
      </div>
      <div class="form-group mt-2">
        <label for="apiUrl">API URL</label>
        <input type="text" id="apiUrl" placeholder="请输入你的 API URL如https://api.example.com" name="apiUrl"
          class="form-control">
      </div>
      <!-- 固定模型为 gpt-image-1 -->
      <div class="form-group mt-2">
        <label>模型</label>
        <input type="text" value="gpt-image-1" class="form-control" readonly>
      </div>
      <div class="form-group mt-2">
        <label for="prompt">提示语</label>
        <textarea id="prompt" placeholder="请输入生成图像的提示语" class="form-control" maxlength="1024" rows="3"></textarea>
      </div>
      <!-- 新增：生成数量 -->
      <div class="form-group mt-2">
        <label for="n">生成数量</label>
        <input type="number" id="n" class="form-control" min="1" value="1">
      </div>
      <!-- 新增：上传第一个图像（遮罩会应用在这个图像） -->
      <div class="form-group mt-2">
        <label for="firstInputImage">上传第一个图像（遮罩会应用在这个图像）</label>
        <input type="file" id="firstInputImage" class="form-control" accept="image/*">
      </div>
      <!-- 新增：上传多个图像（可多选） -->
      <div class="form-group mt-2">
        <label for="multiInputImage">上传多个图像</label>
        <input type="file" id="multiInputImage" class="form-control" accept="image/*" multiple>
      </div>
      <!-- 新增：绘制遮罩相关按钮、画布容器和工具箱 -->
      <div class="form-group mt-2" id="drawMaskGroup">
        <button id="drawMaskBtn" class="btn btn--secondary disabled" type="button">绘制遮罩</button>
        <button id="downloadMaskBtn" class="btn btn--secondary hidden" type="button">下载遮罩</button>
        <p class="text-muted mt-3">提示：遮罩区域(红色/不透明)表示需要保留不被修改的部分，非遮罩区域（透明区域）将被AI修改</p>
        <div id="maskToolbox" class="hidden mt-3 flex">
            <div class="tool-buttons flex gap-1">
              <button id="brushModeBtn" class="btn btn--toggle active" type="button" title="画笔">
                🖌️
              </button>
              <button id="eraserModeBtn" class="btn btn--toggle" type="button" title="橡皮擦">
                🧽
              </button>
              <button id="circleBrushBtn" class="btn btn--toggle active" type="button" title="圆形画笔">
                ⚪
              </button>
              <button id="squareBrushBtn" class="btn btn--toggle" type="button" title="方形画笔">
                ⬜
              </button>
            </div>
            <div class="brush-size-control">
              <label>画笔大小:
                <input type="range" id="maskBrushSize" min="5" max="100" value="30">
                <span id="maskBrushSizeVal">30</span>px
              </label>
            </div>
          </div>
          <div id="maskCanvasContainer" class="hidden relative-position mt-3 flex">
          <!-- 画布和预览光标canvas都放这里 -->
        </div>
      </div>
      <!-- 新增：遮罩上传（用于编辑时局部修改） -->
      <div class="form-group mt-2" id="maskUploadGroup">
        <label for="maskImage">上传遮罩图像（选填）</label>
        <input type="file" id="maskImage" class="form-control" accept="image/*">
      </div>
      <!-- 可选：图像尺寸 -->
      <div class="form-group mt-2">
        <label for="size">图像尺寸</label>
        <select id="size" class="form-control">
          <option value="1024x1024" selected>1024x1024（默认）</option>
          <option value="1024x1536">1024x1536（竖屏）</option>
          <option value="1536x1024">1536x1024（横屏）</option>
          <option value="auto">auto</option>
        </select>
      </div>
      <!-- 新增：图像质量设置 -->
      <div class="form-group mt-2">
        <label for="quality">图像质量</label>
        <select id="quality" class="form-control">
          <option value="low">低</option>
          <option value="medium">中</option>
          <option value="high">高</option>
          <option value="auto" selected>auto</option>
        </select>
      </div>
      <!-- 新增：输出格式 -->
      <div class="form-group mt-2">
        <label for="format">输出格式</label>
        <select id="format" class="form-control">
          <option value="png" selected>PNG</option>
          <option value="jpeg">JPEG</option>
          <option value="webp">WEBP</option>
        </select>
      </div>
      <!-- 新增：背景设置 -->
      <div class="form-group mt-2">
        <label for="background">背景</label>
        <select id="background" class="form-control">
          <option value="opaque" selected>不透明</option>
          <option value="transparent">透明</option>
        </select>
      </div>
      <!-- 新增：压缩率 (仅在JPEG/WebP时生效) -->
      <div class="form-group mt-2">
        <label for="compression">压缩率 (0-100) 0为无损</label>
        <input type="number" id="compression" placeholder="请输入压缩率" class="form-control" min="0" max="100" value="0">
      </div>
      <!-- 新增：内容审核 -->
      <div class="form-group mt-2">
        <label for="moderation">内容审核</label>
        <select id="moderation" class="form-control">
          <option value="auto" selected>auto</option>
          <option value="low">low</option>
        </select>
      </div>
      <div class="form-group mt-3">
        <button id="generateBtn" class="btn btn--primary">生成图像</button>
        <button id="editBtn" class="btn btn--tertiary">编辑图像</button>
        <button id="clearPreviewBtn" class="btn btn--secondary">清空预览</button>
      </div>
      <div id="previewContainer" class="hidden mt-2"></div>
    </div>
  </main>

  <!-- 模板页脚 -->
  <footer class="site-footer">
    <div class="container">
      <div class="footer-grid">
        <div>
          <h3 class="footer-title">关于作者</h3>
          <ul class="footer-links">
            <li><a href="mailto:ttfdg520cs@gmail.com">ttfdg520cs@gmail.com</a></li>
            <li><a href="https://space.bilibili.com/1446349" target="_blank">Bilibili主页</a></li>
            <li><a href="https://github.com/xzxz520cs" target="_blank">GitHub</a></li>
          </ul>
        </div>
      </div>
      <div class="footer-bottom">
        <p class="text-muted">© 2025 天天发蛋糕的工具箱</p>
      </div>
    </div>
  </footer>

  <!-- 脚本部分 -->
  <script>
    // 画笔模式按钮事件
    document.getElementById('brushModeBtn').addEventListener('click', () => {
      maskToolMode = 'brush';
      document.getElementById('brushModeBtn').classList.add('active');
      document.getElementById('eraserModeBtn').classList.remove('active');
    });

    document.getElementById('eraserModeBtn').addEventListener('click', () => {
      maskToolMode = 'eraser';
      document.getElementById('eraserModeBtn').classList.add('active');
      document.getElementById('brushModeBtn').classList.remove('active');
    });

    // 画笔形状按钮事件
    document.getElementById('circleBrushBtn').addEventListener('click', () => {
      brushShape = 'circle';
      document.getElementById('circleBrushBtn').classList.add('active');
      document.getElementById('squareBrushBtn').classList.remove('active');
    });

    document.getElementById('squareBrushBtn').addEventListener('click', () => {
      brushShape = 'square';
      document.getElementById('squareBrushBtn').classList.add('active');
      document.getElementById('circleBrushBtn').classList.remove('active');
    });

    // 初始化：加载并保存 API Key 和 API URL 到 localStorage
    document.addEventListener('DOMContentLoaded', () => {
      // 加载 API Key 和 API URL
      const apiKeyInput = document.getElementById("apiKey");
      const apiUrlInput = document.getElementById("apiUrl");
      if (localStorage.getItem("image_apiKey")) {
        apiKeyInput.value = localStorage.getItem("image_apiKey");
      }
      if (localStorage.getItem("image_apiUrl")) {
        apiUrlInput.value = localStorage.getItem("image_apiUrl");
      }
      apiKeyInput.addEventListener("input", () => {
        localStorage.setItem("image_apiKey", apiKeyInput.value.trim());
      });
      apiUrlInput.addEventListener("input", () => {
        localStorage.setItem("image_apiUrl", apiUrlInput.value.trim());
      });

      // 新增：加载并保存其它设置
      const nInput = document.getElementById("n");
      if (localStorage.getItem("image_n")) {
        nInput.value = localStorage.getItem("image_n");
      }
      nInput.addEventListener("input", () => {
        localStorage.setItem("image_n", nInput.value);
      });

      const sizeSelect = document.getElementById("size");
      if (localStorage.getItem("image_size")) {
        sizeSelect.value = localStorage.getItem("image_size");
      }
      sizeSelect.addEventListener("change", () => {
        localStorage.setItem("image_size", sizeSelect.value);
      });

      const qualitySelect = document.getElementById("quality");
      if (localStorage.getItem("image_quality")) {
        qualitySelect.value = localStorage.getItem("image_quality");
      }
      qualitySelect.addEventListener("change", () => {
        localStorage.setItem("image_quality", qualitySelect.value);
      });

      const formatSelect = document.getElementById("format");
      if (localStorage.getItem("image_format")) {
        formatSelect.value = localStorage.getItem("image_format");
      }
      formatSelect.addEventListener("change", () => {
        localStorage.setItem("image_format", formatSelect.value);
      });

      const backgroundSelect = document.getElementById("background");
      if (localStorage.getItem("image_background")) {
        backgroundSelect.value = localStorage.getItem("image_background");
      }
      backgroundSelect.addEventListener("change", () => {
        localStorage.setItem("image_background", backgroundSelect.value);
      });

      const compressionInput = document.getElementById("compression");
      if (localStorage.getItem("image_compression")) {
        compressionInput.value = localStorage.getItem("image_compression");
      }
      compressionInput.addEventListener("input", () => {
        localStorage.setItem("image_compression", compressionInput.value);
      });

      const moderationSelect = document.getElementById("moderation");
      if (localStorage.getItem("image_moderation")) {
        moderationSelect.value = localStorage.getItem("image_moderation");
      }
      moderationSelect.addEventListener("change", () => {
        localStorage.setItem("image_moderation", moderationSelect.value);
      });
    });

    // 图片上传处理：使用 FileReader 将上传文件转换为 Base64 字符串
    function fileToDataURL(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(new Error("文件读取失败"));
        reader.readAsDataURL(file);
      });
    }

    // 将文件转换为PNG格式的Blob对象
    function fileToPngBlob(file, targetWidth = 0, targetHeight = 0) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        const reader = new FileReader();
        
        reader.onload = (e) => {
          img.onload = () => {
            const canvas = document.createElement('canvas');
            // 如果指定了目标尺寸则使用，否则使用原图尺寸
            canvas.width = targetWidth > 0 ? targetWidth : img.width;
            canvas.height = targetHeight > 0 ? targetHeight : img.height;
            
            const ctx = canvas.getContext('2d');
            // 高质量缩放
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            
            canvas.toBlob((blob) => {
              if (blob) {
                resolve(blob);
              } else {
                reject(new Error('Canvas转Blob失败'));
              }
            }, 'image/png');
          };
          img.onerror = () => reject(new Error('图片加载失败'));
          img.src = e.target.result;
        };
        reader.onerror = () => reject(new Error('文件读取失败'));
        reader.readAsDataURL(file);
      });
    }

    // 画笔绘制函数，需放在setupMaskCanvas前
    let maskToolMode = 'brush';
    let lastDrawX = null, lastDrawY = null;
    function drawAt(e) {
      const rect = maskCanvas.getBoundingClientRect();
      // 计算画布上的坐标(已考虑缩放)
      const x = Math.round((e.clientX - rect.left) * maskCanvas.width / rect.width);
      const y = Math.round((e.clientY - rect.top) * maskCanvas.height / rect.height);

      // 直接绘制当前点
      drawDot(x, y);

      lastDrawX = x;
      lastDrawY = y;
      renderMaskCanvas();
    }
    function drawDot(x, y) {
      const half = Math.floor(brushSize / 2);
      if (brushShape === 'circle') {
        for (let dx = -half; dx <= half; dx++) {
          for (let dy = -half; dy <= half; dy++) {
            if (dx * dx + dy * dy <= half * half) {
              const px = x + dx, py = y + dy;
              if (px >= 0 && px < maskImageData.width && py >= 0 && py < maskImageData.height) {
                const idx = (py * maskImageData.width + px) * 4 + 3;
                maskImageData.data[idx] = (maskToolMode === 'brush') ? 0 : 255;
              }
            }
          }
        }
      } else {
        for (let dx = -half; dx <= half; dx++) {
          for (let dy = -half; dy <= half; dy++) {
            const px = x + dx, py = y + dy;
            if (px >= 0 && px < maskImageData.width && py >= 0 && py < maskImageData.height) {
              const idx = (py * maskImageData.width + px) * 4 + 3;
              maskImageData.data[idx] = (maskToolMode === 'brush') ? 0 : 255;
            }
          }
        }
      }
    }

    // 生成图像逻辑
    document.getElementById("generateBtn").addEventListener("click", async () => {
      const apiKey = document.getElementById("apiKey").value.trim();
      const apiUrl = document.getElementById("apiUrl").value.trim();
      const prompt = document.getElementById("prompt").value.trim();
      const n = parseInt(document.getElementById("n").value) || 1;
      const size = document.getElementById("size").value;
      const quality = document.getElementById("quality").value;
      const formatVal = document.getElementById("format").value;
      const background = document.getElementById("background").value;
      const compression = document.getElementById("compression").value;
      const moderation = document.getElementById("moderation").value;

      if (!apiKey || !apiUrl || !prompt) {
        alert("请输入 API Key、API URL 和提示语！");
        return;
      }

      const generateBtn = document.getElementById("generateBtn");
      generateBtn.disabled = true;
      generateBtn.classList.add('disabled');

      const previewContainer = document.getElementById("previewContainer");
      // 显示占位信息
      const previewItem = document.createElement("div");
      previewItem.className = "image-item mb-2 separator-horizontal";
      previewItem.textContent = "处理中...";
      previewContainer.insertBefore(previewItem, previewContainer.firstChild);
      previewContainer.classList.remove("hidden");

      const data = {
        model: "gpt-image-1",
        prompt: prompt,
        n: n,
        size: size,
        quality: quality,
        output_format: formatVal,
        background: background,
        moderation: moderation
      };

      if ((formatVal === "jpeg" || formatVal === "webp") && compression && parseInt(compression) > 0) {
        data.output_compression = parseInt(compression);
      }

      // 新增：处理上传的输入图像（如果存在）
      const imageFileInput = document.getElementById("multiInputImage");
      if (imageFileInput.files && imageFileInput.files.length > 0) {
        try {
          // 先获取第一张图片的宽高
          let targetWidth = 0, targetHeight = 0;
          {
            const imgProbe = new window.Image();
            const probeUrl = await fileToDataURL(imageFileInput.files[0]);
            await new Promise((res, rej) => {
              imgProbe.onload = res;
              imgProbe.onerror = rej;
              imgProbe.src = probeUrl;
            });
            targetWidth = imgProbe.width;
            targetHeight = imgProbe.height;
          }
          if (imageFileInput.files.length === 1) {
            // 单张图片，转为 PNG DataURL
            const pngBlob = await fileToPngBlob(imageFileInput.files[0], targetWidth, targetHeight);
            const base64Image = await fileToDataURL(pngBlob);
            data.input_image = base64Image;
          } else {
            // 多张图片，全部转为 PNG DataURL
            const base64Images = [];
            for (let i = 0; i < imageFileInput.files.length; i++) {
              const pngBlob = await fileToPngBlob(imageFileInput.files[i], targetWidth, targetHeight);
              base64Images.push(await fileToDataURL(pngBlob));
            }
            data.input_images = base64Images;
          }
        } catch (e) {
          console.error(e);
          alert("读取上传的图像失败！");
          return;
        }
      }

      const baseUrl = apiUrl.replace(/\/+$/, "");
      const generationUrl = baseUrl + "/v1/images/generations";

      try {
        const response = await fetch(generationUrl, {
          method: "POST",
          headers: {
            "Authorization": "Bearer " + apiKey,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(data)
        });

        if (response.ok) {
          const result = await response.json();
          // 提取除图片数据以外的信息并打印到控制台
          const { data, ...otherInfo } = result;
          console.log("API返回内容(除图片数据):", otherInfo);
          if (data && data.length > 0) {
            previewItem.innerHTML = "";
            data.forEach((item, idx) => {
              if (item.b64_json) {
                const mime = (formatVal === "jpeg" || formatVal === "webp") ? formatVal : "png";
                const imageSrc = "data:image/" + mime + ";base64," + item.b64_json;
                const img = document.createElement("img");
                img.className = "full-width";
                img.src = imageSrc;
                const caption = document.createElement("p");
                caption.textContent = prompt + (data.length > 1 ? ` [${idx + 1}]` : "");
                previewItem.appendChild(caption);
                previewItem.appendChild(img);
              }
            });
            if (previewItem.innerHTML === "") {
              previewItem.textContent = "返回数据中无图片数据";
            }
          } else {
            previewItem.textContent = "返回数据中无图片数据";
          }
        } else {
          const errorText = await response.text();
          console.error("详细错误信息：", errorText);
          previewItem.textContent = "请求失败，状态码：" + response.status + "，详细：" + errorText;
        }
      } catch (error) {
        console.error("请求错误详情：", error);
        previewItem.textContent = "请求出现错误：" + error;
      } finally {
        const generateBtn = document.getElementById("generateBtn");
        generateBtn.disabled = false;
        generateBtn.classList.remove('disabled');
      }
    });

    // 清空预览逻辑
    document.getElementById("clearPreviewBtn").addEventListener("click", () => {
      const previewContainer = document.getElementById("previewContainer");
      previewContainer.innerHTML = "";
      previewContainer.classList.add("hidden");
    });

    // 编辑图像逻辑
    document.getElementById("editBtn").addEventListener("click", async () => {
      const apiKey = document.getElementById("apiKey").value.trim();
      const apiUrl = document.getElementById("apiUrl").value.trim();
      const prompt = document.getElementById("prompt").value.trim();
      const n = parseInt(document.getElementById("n").value) || 1;
      const size = document.getElementById("size").value || "1024x1024";
      const quality = document.getElementById("quality").value || "auto";
      const maskInput = document.getElementById("maskImage");
      // 新增：遮罩绘制模式判断
      const isDrawingMask = document.getElementById('drawMaskBtn').textContent === '放弃绘制';
      if (!apiKey || !apiUrl || !prompt) {
        alert("请输入 API Key、API URL 和提示语！");
        return;
      }
      const editBtn = document.getElementById("editBtn");
      editBtn.disabled = true;
      editBtn.classList.add('disabled');
      // 合并所有上传图片，firstInputImage优先
      let files = [];
      if (firstInputImage.files && firstInputImage.files.length > 0) {
        files.push(firstInputImage.files[0]);
      }
      if (multiInputImage.files && multiInputImage.files.length > 0) {
        for (let i = 0; i < multiInputImage.files.length; i++) {
          // 避免重复添加firstInputImage
          if (!firstInputImage.files.length || multiInputImage.files[i] !== firstInputImage.files[0]) {
            files.push(multiInputImage.files[i]);
          }
        }
      }
      if (files.length === 0) {
        alert("请上传要编辑的图像！");
        editBtn.disabled = false;
        editBtn.classList.remove('disabled');
        return;
      }
      if (files.length > 16) {
        alert("最多只能上传16张图片！");
        editBtn.disabled = false;
        editBtn.classList.remove('disabled');
        return;
      }
      // 统一所有图片为 PNG 且尺寸与第一张图一致
      const formData = new FormData();
      formData.append("model", "gpt-image-1");
      formData.append("prompt", prompt);
      formData.append("n", n);
      formData.append("size", size);
      formData.append("quality", quality);

      // 获取目标尺寸（第一张图）
      let targetWidth = 0, targetHeight = 0;
      {
        const imgProbe = new window.Image();
        const probeUrl = await fileToDataURL(files[0]);
        await new Promise((res, rej) => {
          imgProbe.onload = res;
          imgProbe.onerror = rej;
          imgProbe.src = probeUrl;
        });
        targetWidth = imgProbe.width;
        targetHeight = imgProbe.height;
      }

      // 所有图片转为 PNG Blob 并 append
      for (let i = 0; i < files.length; i++) {
        const pngBlob = await fileToPngBlob(files[i], targetWidth, targetHeight);
        formData.append("image[]", pngBlob, "image" + (i + 1) + ".png");
      }

      // 遮罩处理：优先用绘制的遮罩
      if (isDrawingMask && window.maskImageData && window.maskCanvas) {
        // 导出遮罩为PNG Blob（已保证尺寸一致）
        const exportCanvas = document.createElement('canvas');
        exportCanvas.width = maskBaseImage.width;
        exportCanvas.height = maskBaseImage.height;
        const exportCtx = exportCanvas.getContext('2d');
        
        // 创建与绘制尺寸相同的临时画布
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = window.maskImageData.width;
        tempCanvas.height = window.maskImageData.height;
        const tempCtx = tempCanvas.getContext('2d');
        
        // 创建与绘制尺寸相同的ImageData，修正alpha通道为255-原值
        const tempImgData = tempCtx.createImageData(window.maskImageData.width, window.maskImageData.height);
        for (let i = 0; i < window.maskImageData.data.length; i += 4) {
          tempImgData.data[i] = 0;
          tempImgData.data[i + 1] = 0;
          tempImgData.data[i + 2] = 0;
          tempImgData.data[i + 3] = 255 - window.maskImageData.data[i + 3]; // 反转alpha
        }
        tempCtx.putImageData(tempImgData, 0, 0);
        
        // 使用高质量缩放将临时画布拉伸到原图尺寸
        exportCtx.imageSmoothingEnabled = true;
        exportCtx.imageSmoothingQuality = 'high';
        exportCtx.drawImage(tempCanvas, 0, 0, maskBaseImage.width, maskBaseImage.height);
        // 修正：拉伸后再二值化alpha通道，确保只有0/255
        const exportImgData = exportCtx.getImageData(0, 0, exportCanvas.width, exportCanvas.height);
        for (let i = 0; i < exportImgData.data.length; i += 4) {
          exportImgData.data[i] = 0;
          exportImgData.data[i + 1] = 0;
          exportImgData.data[i + 2] = 0;
          exportImgData.data[i + 3] = exportImgData.data[i + 3] > 127 ? 255 : 0;
        }
        exportCtx.putImageData(exportImgData, 0, 0);
        // toBlob为异步
        await new Promise((resolve, reject) => {
          exportCanvas.toBlob(blob => {
            if (blob) {
              formData.append("mask", blob, "mask.png");
              resolve();
            } else {
              alert("遮罩导出失败");
              reject();
            }
          }, 'image/png');
        });
      } else if (maskInput.files && maskInput.files.length > 0) {
        // 遮罩上传也转为 PNG 且尺寸与第一张图一致
        // 需要修正alpha通道为255-原值
        const maskPngBlob = await fileToPngBlob(maskInput.files[0], targetWidth, targetHeight);
        // 读取blob为ImageData，反转alpha后再导出
        const maskImg = new window.Image();
        maskImg.src = await fileToDataURL(maskPngBlob);
        await new Promise(res => { maskImg.onload = res; });
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = maskImg.width;
        tempCanvas.height = maskImg.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(maskImg, 0, 0);
        const imgData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        for (let i = 0; i < imgData.data.length; i += 4) {
          imgData.data[i + 3] = 255 - imgData.data[i + 3];
        }
        tempCtx.putImageData(imgData, 0, 0);
        await new Promise((resolve, reject) => {
          tempCanvas.toBlob(blob => {
            if (blob) {
              formData.append("mask", blob, "mask.png");
              resolve();
            } else {
              alert("遮罩导出失败");
              reject();
            }
          }, 'image/png');
        });
      }
      const baseUrl = apiUrl.replace(/\/+/g, "");
      const editUrl = baseUrl + "/v1/images/edits";
      const previewContainer = document.getElementById("previewContainer");
      const previewItem = document.createElement("div");
      previewItem.className = "image-item mb-2 separator-horizontal";
      previewItem.textContent = "处理中...";
      previewContainer.insertBefore(previewItem, previewContainer.firstChild);
      previewContainer.classList.remove("hidden");
      try {
        const response = await fetch(editUrl, {
          method: "POST",
          headers: {
            "Authorization": "Bearer " + apiKey
            // 不要加 Content-Type，fetch 会自动设置 multipart/form-data
          },
          body: formData
        });
        if (response.ok) {
          const result = await response.json();
          const formatVal = document.getElementById("format").value;
          if (result.data && result.data.length > 0) {
            previewItem.innerHTML = "";
            result.data.forEach((item, idx) => {
              if (item.b64_json) {
                const mime = (formatVal === "jpeg" || formatVal === "webp") ? formatVal : "png";
                const imageSrc = "data:image/" + mime + ";base64," + item.b64_json;
                const img = document.createElement("img");
                img.className = "full-width";
                img.src = imageSrc;
                const caption = document.createElement("p");
                caption.textContent = prompt + (result.data.length > 1 ? ` [${idx + 1}]` : "");
                previewItem.appendChild(caption);
                previewItem.appendChild(img);
              }
            });
            if (previewItem.innerHTML === "") {
              previewItem.textContent = "返回数据中无图片数据";
            }
          } else {
            previewItem.textContent = "返回数据中无图片数据";
          }
        } else {
          const errorText = await response.text();
          console.error("详细错误信息：", errorText);
          previewItem.textContent = "请求失败，状态码：" + response.status + "，详细：" + errorText;
        }
      } catch (error) {
        console.error("请求错误详情：", error);
        previewItem.textContent = "请求出现错误：" + error;
      } finally {
        const editBtn = document.getElementById("editBtn");
        editBtn.disabled = false;
        editBtn.classList.remove('disabled');
      }
    });

    // 新增：遮罩绘制按钮可用性
    const drawMaskBtn = document.getElementById("drawMaskBtn");
    const maskUploadGroup = document.getElementById("maskUploadGroup");
    const maskCanvasContainer = document.getElementById("maskCanvasContainer");
    const maskToolbox = document.getElementById("maskToolbox");
    const downloadMaskBtn = document.getElementById("downloadMaskBtn");
    const firstInputImage = document.getElementById("firstInputImage");
    const multiInputImage = document.getElementById("multiInputImage");
    let maskCanvas = null;
    let maskCtx = null;
    let drawing = false;
    let brushShape = 'circle';
    // 默认画笔大小
    let brushSize = 30; // 直径/边长
    let maskImageData = null;
    let maskBaseImage = null;
    let isDrawingMask = false;
    let maskCursorOverlay = null;

    function getMaskTargetFile() {
      // 优先使用firstInputImage，否则multiInputImage的第一张
      if (firstInputImage.files && firstInputImage.files.length > 0) {
        return firstInputImage.files[0];
      } else if (multiInputImage.files && multiInputImage.files.length > 0) {
        return multiInputImage.files[0];
      } else {
        return null;
      }
    }

    // 画笔大小调节事件监听
    const brushSizeInput = document.getElementById('maskBrushSize');
    const brushSizeVal = document.getElementById('maskBrushSizeVal');
    if (brushSizeInput && brushSizeVal) {
      brushSizeInput.addEventListener('input', function () {
        brushSize = parseInt(brushSizeInput.value, 10);
        brushSizeVal.textContent = brushSize;
      });
    }

    function exitDrawMaskMode() {
      isDrawingMask = false;
      drawMaskBtn.textContent = '绘制遮罩';
      maskUploadGroup.classList.remove("hidden");
      maskCanvasContainer.classList.add("hidden");
      maskToolbox.classList.add("hidden");
      downloadMaskBtn.classList.add("hidden");
      if (maskCanvasContainer.firstChild) maskCanvasContainer.removeChild(maskCanvasContainer.firstChild);
      maskCanvas = null;
      maskCtx = null;
      maskImageData = null;
      maskBaseImage = null;
    }
    // 监听输入图片变化，决定绘制遮罩按钮可用性，并在图片被移除时退出绘制模式
    function updateDrawMaskBtnState() {
      if (getMaskTargetFile()) {
        drawMaskBtn.classList.remove('disabled');
      } else {
        drawMaskBtn.classList.add('disabled');
        if (isDrawingMask) {
          exitDrawMaskMode();
        }
      }
    }
    firstInputImage.addEventListener('change', updateDrawMaskBtnState);
    multiInputImage.addEventListener('change', updateDrawMaskBtnState);

    // 绘制遮罩按钮逻辑
    drawMaskBtn.addEventListener('click', async () => {
      if (!isDrawingMask) {
        // 进入绘制模式
        isDrawingMask = true;
        drawMaskBtn.textContent = '放弃绘制';
        maskUploadGroup.classList.add("hidden");
        maskCanvasContainer.classList.remove("hidden");
        maskToolbox.classList.remove("hidden");
        downloadMaskBtn.classList.remove("hidden");
        // 初始化画布
        await setupMaskCanvas();
      } else {
        // 退出绘制模式
        exitDrawMaskMode();
      }
    });

    // 初始化遮罩画布
    async function setupMaskCanvas() {
      // 清空容器
      maskCanvasContainer.innerHTML = '';
      maskCanvas = document.createElement('canvas');
      maskCanvas.style.border = '1px solid #ccc';
      maskCanvas.style.display = 'block';
      maskCanvas.style.position = 'relative';
      maskCanvasContainer.appendChild(maskCanvas);
      // 明确使用firstInputImage或multiInputImage的第一张
      const file = getMaskTargetFile();
      if (!file) {
        alert("请先上传图片！");
        exitDrawMaskMode();
        return;
      }
      const img = new window.Image();
      img.src = await fileToDataURL(file);
      await new Promise(res => { img.onload = res; });
      maskBaseImage = img;
      
      // 计算绘制画布尺寸 (最大高度768，最大宽度1532)
      let drawWidth = img.width, drawHeight = img.height;
      if (img.height > 768 || img.width > 1532) {
        const scale = Math.min(768 / img.height, 1532 / img.width);
        drawWidth = Math.round(img.width * scale);
        drawHeight = Math.round(img.height * scale);
      }
      
      // 设置画布实际尺寸为绘制尺寸
      maskCanvas.width = drawWidth;
      maskCanvas.height = drawHeight;
      // 显示尺寸与绘制尺寸相同
      maskCanvas.style.width = drawWidth + 'px';
      maskCanvas.style.height = drawHeight + 'px';
      maskCtx = maskCanvas.getContext('2d');
      // 新建遮罩层（全不透明）- 使用绘制尺寸而非原图尺寸
      maskImageData = maskCtx.createImageData(drawWidth, drawHeight);
      for (let i = 0; i < maskImageData.data.length; i += 4) {
        maskImageData.data[i + 3] = 255; // alpha=255
      }
      // 动态设置画笔最大值为缩放后图片长边的1.1倍
      const scaledMaxDimension = Math.max(img.width, img.height); // 获取缩放后的长边
      const maxBrushSize = Math.round(scaledMaxDimension * 1.1);
      const brushSizeInput = document.getElementById('maskBrushSize');
      brushSizeInput.max = maxBrushSize;
      // 若当前brushSize超出最大值，重置
      if (brushSize > maxBrushSize) {
        brushSize = maxBrushSize;
        brushSizeInput.value = brushSize;
        document.getElementById('maskBrushSizeVal').textContent = brushSize;
      } else {
        // 同步显示
        brushSizeInput.value = brushSize;
        document.getElementById('maskBrushSizeVal').textContent = brushSize;
      }
      // 预览光标canvas（全局唯一）
      if (!maskCursorOverlay) {
        maskCursorOverlay = document.createElement('canvas');
        maskCursorOverlay.style.position = 'absolute';
        maskCursorOverlay.style.left = '0';
        maskCursorOverlay.style.top = '0';
        maskCursorOverlay.style.pointerEvents = 'none';
        maskCanvasContainer.appendChild(maskCursorOverlay);
      } else {
        maskCanvasContainer.appendChild(maskCursorOverlay);
      }
      maskCursorOverlay.width = maskCanvas.width;
      maskCursorOverlay.height = maskCanvas.height;
      maskCursorOverlay.style.width = maskCanvas.style.width;
      maskCursorOverlay.style.height = maskCanvas.style.height;
      // 画布事件
      maskCanvas.onmousedown = e => { drawing = true; lastDrawX = lastDrawY = null; drawAt(e); };
      maskCanvas.onmouseup = () => { drawing = false; lastDrawX = lastDrawY = null; };
      maskCanvas.onmouseleave = () => { drawing = false; lastDrawX = lastDrawY = null; maskCursorOverlay.classList.add('hidden'); };
      maskCanvas.onmousemove = e => {
        if (drawing) drawAt(e);
        drawCursorOverlay(e);
      };
      maskCanvas.onmouseenter = e => { maskCursorOverlay.classList.remove('hidden'); drawCursorOverlay(e); };
      // 触摸支持（不显示预览）
      maskCanvas.ontouchstart = e => { drawing = true; lastDrawX = lastDrawY = null; drawAt(e.touches[0]); e.preventDefault(); maskCursorOverlay.classList.add('hidden'); };
      maskCanvas.ontouchend = () => { drawing = false; lastDrawX = lastDrawY = null; };
      maskCanvas.ontouchcancel = () => { drawing = false; lastDrawX = lastDrawY = null; };
      maskCanvas.ontouchmove = e => { if (drawing) drawAt(e.touches[0]); e.preventDefault(); maskCursorOverlay.classList.add('hidden'); };
      // 预览光标绘制函数
      function drawCursorOverlay(e) {
        const rect = maskCanvas.getBoundingClientRect();
        const x = Math.round((e.clientX - rect.left) * maskCanvas.width / rect.width);
        const y = Math.round((e.clientY - rect.top) * maskCanvas.height / rect.height);
        const ctx = maskCursorOverlay.getContext('2d');
        ctx.clearRect(0, 0, maskCursorOverlay.width, maskCursorOverlay.height);
        ctx.save();
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#fff';
        ctx.shadowColor = '#000';
        ctx.shadowBlur = 0;
        ctx.beginPath();
        const half = brushSize / 2;
        if (brushShape === 'circle') {
          ctx.arc(x, y, half, 0, 2 * Math.PI);
        } else {
          ctx.rect(x - half, y - half, brushSize, brushSize);
        }
        ctx.stroke();
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#000';
        ctx.shadowColor = 'transparent';
        ctx.beginPath();
        if (brushShape === 'circle') {
          ctx.arc(x, y, half, 0, 2 * Math.PI);
        } else {
          ctx.rect(x - half, y - half, brushSize, brushSize);
        }
        ctx.stroke();
        ctx.restore();
      }
      // 初始渲染
      renderMaskCanvas();
    }
    function renderMaskCanvas() {
      // 先画底图
      maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
      maskCtx.drawImage(maskBaseImage, 0, 0, maskCanvas.width, maskCanvas.height);
      // 用离屏canvas生成红色遮罩层
      const maskVisCanvas = document.createElement('canvas');
      maskVisCanvas.width = maskImageData.width;
      maskVisCanvas.height = maskImageData.height;
      const visCtx = maskVisCanvas.getContext('2d');
      const visImg = visCtx.createImageData(maskImageData.width, maskImageData.height);
      for (let i = 0; i < maskImageData.data.length; i += 4) {
        if (maskImageData.data[i + 3] === 0) {
          visImg.data[i] = 255; visImg.data[i + 1] = 0; visImg.data[i + 2] = 0; visImg.data[i + 3] = 180; // 红色更明显
        } else {
          visImg.data[i + 3] = 0;
        }
      }
      visCtx.putImageData(visImg, 0, 0);
      maskCtx.drawImage(maskVisCanvas, 0, 0, maskCanvas.width, maskCanvas.height);
    }
    // 下载遮罩
    downloadMaskBtn.addEventListener('click', () => {
      if (!maskCanvas || !maskImageData) return;
      // 创建原图尺寸的导出画布
      const exportCanvas = document.createElement('canvas');
      exportCanvas.width = maskBaseImage.width;
      exportCanvas.height = maskBaseImage.height;
      const exportCtx = exportCanvas.getContext('2d');
      
      // 先将遮罩绘制到临时画布
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = maskImageData.width;
      tempCanvas.height = maskImageData.height;
      const tempCtx = tempCanvas.getContext('2d');
      const tempImgData = tempCtx.createImageData(maskImageData.width, maskImageData.height);
      for (let i = 0; i < maskImageData.data.length; i += 4) {
        tempImgData.data[i] = 0;
        tempImgData.data[i + 1] = 0;
        tempImgData.data[i + 2] = 0;
        tempImgData.data[i + 3] = 255 - maskImageData.data[i + 3];
      }
      tempCtx.putImageData(tempImgData, 0, 0);
      
      // 将临时画布拉伸到原图尺寸
      exportCtx.drawImage(tempCanvas, 0, 0, maskBaseImage.width, maskBaseImage.height);
      exportCanvas.toBlob(blob => {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'mask.png';
        a.click();
      }, 'image/png');
    });
    // 退出绘制模式时，恢复遮罩上传
    document.getElementById("maskImage").addEventListener('change', () => {
      if (isDrawingMask) {
        exitDrawMaskMode();
      }
    });
  </script>
</body>

</html>