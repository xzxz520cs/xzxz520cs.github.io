<!DOCTYPE html>
<html lang="zh-cn">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="gpt-image-1 API 图像生成调用工具（需自备 API KEY）">
  <meta name="keywords" content="gpt-image-1, 图像生成, API, 工具">
  <title>gpt-image-1 API 图像生成调用工具 - 天天发蛋糕的工具箱</title>
  <link rel="stylesheet" href="../../assets/css/styles.css">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-HYJXFSRHF5"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-HYJXFSRHF5');
  </script>
</head>

<body>
  <!-- 模板页头 -->
  <header class="site-header">
    <div class="container">
      <div class="site-title">
        <a href="/" class="site-title-link">
          <span class="site-title">天天发蛋糕的工具箱</span>
        </a>
      </div>
      <label for="menu-toggle-checkbox" class="menu-toggle" aria-label="打开菜单">☰</label>
      <nav class="nav-menu">
        <ul class="nav-list">
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" aria-haspopup="true" aria-expanded="false">工具</a>
            <ul class="dropdown-menu">
              <li><a href="/tools/yu-gi-oh-probability-calculator/" class="dropdown-item">游戏王概率计算器</a></li>
              <li><a href="/tools/card-translate/" class="dropdown-item">游戏王卡牌日中对照文本生成器</a></li>
              <li><a href="/tools/webp-avif-2-jpg-png/" class="dropdown-item">AVIF/WebP转JPG/PNG</a></li>
              <li><a href="https://chromewebstore.google.com/detail/kmnmkpgmneeokldcmfcgjppgpcfecoed"
                  class="dropdown-item">恢复关闭的标签页</a></li>
            </ul>
          </li>
        </ul>
      </nav>
    </div>
    <input type="checkbox" id="menu-toggle-checkbox" hidden>
    <div class="drawer">
      <div class="container">
        <label for="menu-toggle-checkbox" class="menu-toggle close-menu" aria-label="关闭菜单">×</label>
      </div>
      <nav class="drawer-menu">
        <ul class="drawer-list">
          <li class="drawer-item">
            <a href="#" class="drawer-link">工具</a>
            <ul class="drawer-submenu">
              <li><a href="/tools/yu-gi-oh-probability-calculator/" class="drawer-subitem">游戏王概率计算器</a></li>
              <li><a href="/tools/card-translate/" class="drawer-subitem">游戏王卡牌日中对照文本生成器</a></li>
              <li><a href="/tools/webp-avif-2-jpg-png/" class="drawer-subitem">AVIF/WebP转JPG/PNG</a></li>
              <li><a href="https://chromewebstore.google.com/detail/kmnmkpgmneeokldcmfcgjppgpcfecoed"
                  class="drawer-subitem">恢复关闭的标签页</a></li>
            </ul>
          </li>
        </ul>
      </nav>
    </div>
    <label for="menu-toggle-checkbox" class="drawer-overlay"></label>
  </header>

  <!-- 主内容区域 -->
  <main class="container">
    <h1 class="mt-0 mb-3">gpt-image-1 API 图像生成调用工具</h1>
    <div class="card card--elevated">
      <div class="form-group mt-2">
        <label for="apiKey">API Key</label>
        <input type="text" id="apiKey" placeholder="请输入你的 API Key" name="apiKey" autocomplete="on" class="form-control">
      </div>
      <div class="form-group mt-2">
        <label for="apiUrl">API URL</label>
        <input type="text" id="apiUrl" placeholder="请输入你的 API URL如https://api.example.com" name="apiUrl"
          class="form-control">
      </div>
      <!-- 固定模型为 gpt-image-1 -->
      <div class="form-group mt-2">
        <label>模型</label>
        <input type="text" value="gpt-image-1" class="form-control" readonly>
      </div>
      <div class="form-group mt-2">
        <label for="prompt">提示语</label>
        <textarea id="prompt" placeholder="请输入生成图像的提示语" class="form-control" maxlength="1024" rows="3"></textarea>
      </div>
      <!-- 新增：生成数量 -->
      <div class="form-group mt-2">
        <label for="n">生成数量</label>
        <input type="number" id="n" class="form-control" min="1" value="1">
      </div>
      <!-- 新增：上传输入图像（支持多选，用于生成或编辑） -->
      <div class="form-group mt-2">
        <label for="inputImage">上传输入图像</label>
        <input type="file" id="inputImage" class="form-control" accept="image/*" multiple>
      </div>
      <!-- 新增：绘制遮罩相关按钮、画布容器和工具箱 -->
      <div class="form-group mt-2" id="drawMaskGroup">
        <button id="drawMaskBtn" class="btn btn--secondary" type="button" disabled>绘制遮罩</button>
        <button id="downloadMaskBtn" class="btn btn--secondary" type="button" style="display:none;">下载遮罩</button>
        <div id="maskCanvasContainer" style="display:none; position:relative; margin-top:10px;">
          <!-- 画布和预览光标canvas都放这里 -->
        </div>
        <div id="maskToolbox" style="display:none; margin-top:8px;">
          <label>模式:
            <select id="maskToolMode">
              <option value="brush">画笔</option>
              <option value="eraser">橡皮擦</option>
            </select>
          </label>
          <label style="margin-left:10px;">画笔形状:
            <select id="maskBrushShape">
              <option value="circle">圆形</option>
              <option value="square">方形</option>
            </select>
          </label>
          <label style="margin-left:10px;">画笔大小:
            <input type="range" id="maskBrushSize" min="5" max="100" value="30">
            <span id="maskBrushSizeVal">30</span>px
          </label>
        </div>
      </div>
      <!-- 新增：遮罩上传（用于编辑时局部修改） -->
      <div class="form-group mt-2" id="maskUploadGroup">
        <label for="maskImage">上传遮罩图像（选填）</label>
        <input type="file" id="maskImage" class="form-control" accept="image/*">
      </div>
      <!-- 可选：图像尺寸 -->
      <div class="form-group mt-2">
        <label for="size">图像尺寸</label>
        <select id="size" class="form-control">
          <option value="1024x1024" selected>1024x1024</option>
          <option value="1024x1536">1024x1536</option>
          <option value="1536x1024">1536x1024</option>
          <option value="auto">auto</option>
        </select>
      </div>
      <!-- 新增：图像质量设置 -->
      <div class="form-group mt-2">
        <label for="quality">图像质量</label>
        <select id="quality" class="form-control">
          <option value="low">低</option>
          <option value="medium">中</option>
          <option value="high">高</option>
          <option value="auto" selected>auto</option>
        </select>
      </div>
      <!-- 新增：输出格式 -->
      <div class="form-group mt-2">
        <label for="format">输出格式</label>
        <select id="format" class="form-control">
          <option value="png" selected>PNG</option>
          <option value="jpeg">JPEG</option>
          <option value="webp">WEBP</option>
        </select>
      </div>
      <!-- 新增：背景设置 -->
      <div class="form-group mt-2">
        <label for="background">背景</label>
        <select id="background" class="form-control">
          <option value="opaque" selected>不透明</option>
          <option value="transparent">透明</option>
        </select>
      </div>
      <!-- 新增：压缩率 (仅在JPEG/WebP时生效) -->
      <div class="form-group mt-2">
        <label for="compression">压缩率 (0-100)</label>
        <input type="number" id="compression" placeholder="请输入压缩率" class="form-control" min="0" max="100" value="0">
      </div>
      <!-- 新增：内容审核 -->
      <div class="form-group mt-2">
        <label for="moderation">内容审核</label>
        <select id="moderation" class="form-control">
          <option value="auto" selected>auto</option>
          <option value="low">low</option>
        </select>
      </div>
      <div class="form-group mt-3">
        <button id="generateBtn" class="btn btn--primary">生成图像</button>
        <button id="editBtn" class="btn btn--tertiary">编辑图像</button>
        <button id="clearPreviewBtn" class="btn btn--secondary">清空预览</button>
      </div>
      <div id="previewContainer" class="hidden mt-2"></div>
    </div>
  </main>

  <!-- 模板页脚 -->
  <footer class="site-footer">
    <div class="container">
      <div class="footer-grid">
        <div>
          <h3 class="footer-title">关于作者</h3>
          <ul class="footer-links">
            <li><a href="mailto:ttfdg520cs@gmail.com">ttfdg520cs@gmail.com</a></li>
            <li><a href="https://space.bilibili.com/1446349" target="_blank">Bilibili主页</a></li>
            <li><a href="https://github.com/xzxz520cs" target="_blank">GitHub</a></li>
          </ul>
        </div>
      </div>
      <div class="footer-bottom">
        <p class="text-muted">© 2025 天天发蛋糕的工具箱</p>
      </div>
    </div>
  </footer>

  <!-- 脚本部分 -->
  <script>
    // 初始化：加载并保存 API Key 和 API URL 到 localStorage
    document.addEventListener('DOMContentLoaded', () => {
      // 加载 API Key 和 API URL
      const apiKeyInput = document.getElementById("apiKey");
      const apiUrlInput = document.getElementById("apiUrl");
      if (localStorage.getItem("image_apiKey")) {
        apiKeyInput.value = localStorage.getItem("image_apiKey");
      }
      if (localStorage.getItem("image_apiUrl")) {
        apiUrlInput.value = localStorage.getItem("image_apiUrl");
      }
      apiKeyInput.addEventListener("input", () => {
        localStorage.setItem("image_apiKey", apiKeyInput.value.trim());
      });
      apiUrlInput.addEventListener("input", () => {
        localStorage.setItem("image_apiUrl", apiUrlInput.value.trim());
      });

      // 新增：加载并保存其它设置
      const nInput = document.getElementById("n");
      if (localStorage.getItem("image_n")) {
        nInput.value = localStorage.getItem("image_n");
      }
      nInput.addEventListener("input", () => {
        localStorage.setItem("image_n", nInput.value);
      });

      const sizeSelect = document.getElementById("size");
      if (localStorage.getItem("image_size")) {
        sizeSelect.value = localStorage.getItem("image_size");
      }
      sizeSelect.addEventListener("change", () => {
        localStorage.setItem("image_size", sizeSelect.value);
      });

      const qualitySelect = document.getElementById("quality");
      if (localStorage.getItem("image_quality")) {
        qualitySelect.value = localStorage.getItem("image_quality");
      }
      qualitySelect.addEventListener("change", () => {
        localStorage.setItem("image_quality", qualitySelect.value);
      });

      const formatSelect = document.getElementById("format");
      if (localStorage.getItem("image_format")) {
        formatSelect.value = localStorage.getItem("image_format");
      }
      formatSelect.addEventListener("change", () => {
        localStorage.setItem("image_format", formatSelect.value);
      });

      const backgroundSelect = document.getElementById("background");
      if (localStorage.getItem("image_background")) {
        backgroundSelect.value = localStorage.getItem("image_background");
      }
      backgroundSelect.addEventListener("change", () => {
        localStorage.setItem("image_background", backgroundSelect.value);
      });

      const compressionInput = document.getElementById("compression");
      if (localStorage.getItem("image_compression")) {
        compressionInput.value = localStorage.getItem("image_compression");
      }
      compressionInput.addEventListener("input", () => {
        localStorage.setItem("image_compression", compressionInput.value);
      });

      const moderationSelect = document.getElementById("moderation");
      if (localStorage.getItem("image_moderation")) {
        moderationSelect.value = localStorage.getItem("image_moderation");
      }
      moderationSelect.addEventListener("change", () => {
        localStorage.setItem("image_moderation", moderationSelect.value);
      });
    });

    // 图片上传处理：使用 FileReader 将上传文件转换为 Base64 字符串
    function fileToDataURL(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(new Error("文件读取失败"));
        reader.readAsDataURL(file);
      });
    }

    // 画笔绘制函数，需放在setupMaskCanvas前
    let maskToolMode = 'brush';
    let lastDrawX = null, lastDrawY = null;
    document.getElementById('maskToolMode').addEventListener('change', e => {
      maskToolMode = e.target.value;
    });
    function drawAt(e) {
      const rect = maskCanvas.getBoundingClientRect();
      const x = Math.round((e.clientX - rect.left) * maskCanvas.width / rect.width);
      const y = Math.round((e.clientY - rect.top) * maskCanvas.height / rect.height);
      // 连续性优化：插值补点
      if (lastDrawX !== null && lastDrawY !== null) {
        const dx = x - lastDrawX, dy = y - lastDrawY;
        const steps = Math.max(Math.abs(dx), Math.abs(dy));
        for (let s = 1; s <= steps; s++) {
          const ix = Math.round(lastDrawX + dx * s / steps);
          const iy = Math.round(lastDrawY + dy * s / steps);
          drawDot(ix, iy);
        }
      } else {
        drawDot(x, y);
      }
      lastDrawX = x;
      lastDrawY = y;
      renderMaskCanvas();
    }
    function drawDot(x, y) {
      const half = Math.floor(brushSize / 2);
      if (brushShape === 'circle') {
        for (let dx = -half; dx <= half; dx++) {
          for (let dy = -half; dy <= half; dy++) {
            if (dx * dx + dy * dy <= half * half) {
              const px = x + dx, py = y + dy;
              if (px >= 0 && px < maskImageData.width && py >= 0 && py < maskImageData.height) {
                const idx = (py * maskImageData.width + px) * 4 + 3;
                maskImageData.data[idx] = (maskToolMode === 'brush') ? 0 : 255;
              }
            }
          }
        }
      } else {
        for (let dx = -half; dx <= half; dx++) {
          for (let dy = -half; dy <= half; dy++) {
            const px = x + dx, py = y + dy;
            if (px >= 0 && px < maskImageData.width && py >= 0 && py < maskImageData.height) {
              const idx = (py * maskImageData.width + px) * 4 + 3;
              maskImageData.data[idx] = (maskToolMode === 'brush') ? 0 : 255;
            }
          }
        }
      }
    }

    // 生成图像逻辑
    document.getElementById("generateBtn").addEventListener("click", async () => {
      const apiKey = document.getElementById("apiKey").value.trim();
      const apiUrl = document.getElementById("apiUrl").value.trim();
      const prompt = document.getElementById("prompt").value.trim();
      const n = parseInt(document.getElementById("n").value) || 1;
      const size = document.getElementById("size").value;
      const quality = document.getElementById("quality").value;
      const formatVal = document.getElementById("format").value;
      const background = document.getElementById("background").value;
      const compression = document.getElementById("compression").value;
      const moderation = document.getElementById("moderation").value;

      if (!apiKey || !apiUrl || !prompt) {
        alert("请输入 API Key、API URL 和提示语！");
        return;
      }

      const previewContainer = document.getElementById("previewContainer");
      // 显示占位信息
      const previewItem = document.createElement("div");
      previewItem.className = "image-item mb-2 separator-horizontal";
      previewItem.textContent = "处理中...";
      previewContainer.insertBefore(previewItem, previewContainer.firstChild);
      previewContainer.classList.remove("hidden");

      const data = {
        model: "gpt-image-1",
        prompt: prompt,
        n: n,
        size: size,
        quality: quality,
        output_format: formatVal,
        background: background,
        moderation: moderation
      };

      if ((formatVal === "jpeg" || formatVal === "webp") && compression && parseInt(compression) > 0) {
        data.output_compression = parseInt(compression);
      }

      // 新增：处理上传的输入图像（如果存在）
      const imageFileInput = document.getElementById("inputImage");
      if (imageFileInput.files && imageFileInput.files.length > 0) {
        try {
          if (imageFileInput.files.length === 1) {
            // 单张图片，兼容旧API
            const base64Image = await fileToDataURL(imageFileInput.files[0]);
            data.input_image = base64Image;
          } else {
            // 多张图片，融合
            const base64Images = [];
            for (let i = 0; i < imageFileInput.files.length; i++) {
              base64Images.push(await fileToDataURL(imageFileInput.files[i]));
            }
            data.input_images = base64Images;
          }
        } catch (e) {
          console.error(e);
          alert("读取上传的图像失败！");
          return;
        }
      }

      const baseUrl = apiUrl.replace(/\/+$/, "");
      const generationUrl = baseUrl + "/v1/images/generations";

      try {
        const response = await fetch(generationUrl, {
          method: "POST",
          headers: {
            "Authorization": "Bearer " + apiKey,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(data)
        });

        if (response.ok) {
          const result = await response.json();
          // 提取除图片数据以外的信息并打印到控制台
          const { data, ...otherInfo } = result;
          console.log("API返回内容(除图片数据):", otherInfo);
          if (data && data.length > 0) {
            previewItem.innerHTML = "";
            data.forEach((item, idx) => {
              if (item.b64_json) {
                const mime = (formatVal === "jpeg" || formatVal === "webp") ? formatVal : "png";
                const imageSrc = "data:image/" + mime + ";base64," + item.b64_json;
                const img = document.createElement("img");
                img.className = "full-width";
                img.src = imageSrc;
                const caption = document.createElement("p");
                caption.textContent = prompt + (data.length > 1 ? ` [${idx + 1}]` : "");
                previewItem.appendChild(caption);
                previewItem.appendChild(img);
              }
            });
            if (previewItem.innerHTML === "") {
              previewItem.textContent = "返回数据中无图片数据";
            }
          } else {
            previewItem.textContent = "返回数据中无图片数据";
          }
        } else {
          const errorText = await response.text();
          console.error("详细错误信息：", errorText);
          previewItem.textContent = "请求失败，状态码：" + response.status + "，详细：" + errorText;
        }
      } catch (error) {
        console.error("请求错误详情：", error);
        previewItem.textContent = "请求出现错误：" + error;
      }
    });

    // 清空预览逻辑
    document.getElementById("clearPreviewBtn").addEventListener("click", () => {
      const previewContainer = document.getElementById("previewContainer");
      previewContainer.innerHTML = "";
      previewContainer.classList.add("hidden");
    });

    // 编辑图像逻辑
    document.getElementById("editBtn").addEventListener("click", async () => {
      const apiKey = document.getElementById("apiKey").value.trim();
      const apiUrl = document.getElementById("apiUrl").value.trim();
      const prompt = document.getElementById("prompt").value.trim();
      const n = parseInt(document.getElementById("n").value) || 1;
      const size = document.getElementById("size").value || "1024x1024";
      const quality = document.getElementById("quality").value || "auto";
      const imageInput = document.getElementById("inputImage");
      const maskInput = document.getElementById("maskImage");
      // 新增：遮罩绘制模式判断
      const isDrawingMask = document.getElementById('drawMaskBtn').textContent === '放弃绘制';
      if (!apiKey || !apiUrl || !prompt) {
        alert("请输入 API Key、API URL 和提示语！");
        return;
      }
      if (!imageInput.files || imageInput.files.length === 0) {
        alert("请上传要编辑的图像！");
        return;
      }
      if (imageInput.files.length > 16) {
        alert("最多只能上传16张图片！");
        return;
      }
      const formData = new FormData();
      formData.append("model", "gpt-image-1");
      formData.append("prompt", prompt);
      formData.append("n", n);
      formData.append("size", size);
      formData.append("quality", quality);
      for (let i = 0; i < imageInput.files.length; i++) {
        formData.append("image[]", imageInput.files[i], imageInput.files[i].name);
      }
      // 遮罩处理：优先用绘制的遮罩
      if (isDrawingMask && window.maskImageData && window.maskCanvas) {
        // 导出遮罩为PNG Blob
        const exportCanvas = document.createElement('canvas');
        exportCanvas.width = window.maskImageData.width;
        exportCanvas.height = window.maskImageData.height;
        const exportCtx = exportCanvas.getContext('2d');
        const imgData = exportCtx.createImageData(window.maskImageData.width, window.maskImageData.height);
        for (let i = 0; i < window.maskImageData.data.length; i += 4) {
          imgData.data[i] = 0;
          imgData.data[i + 1] = 0;
          imgData.data[i + 2] = 0;
          imgData.data[i + 3] = window.maskImageData.data[i + 3];
        }
        exportCtx.putImageData(imgData, 0, 0);
        // toBlob为异步
        await new Promise((resolve, reject) => {
          exportCanvas.toBlob(blob => {
            if (blob) {
              formData.append("mask", blob, "mask.png");
              resolve();
            } else {
              alert("遮罩导出失败");
              reject();
            }
          }, 'image/png');
        });
      } else if (maskInput.files && maskInput.files.length > 0) {
        formData.append("mask", maskInput.files[0], maskInput.files[0].name);
      }
      const baseUrl = apiUrl.replace(/\/+/g, "");
      const editUrl = baseUrl + "/v1/images/edits";
      const previewContainer = document.getElementById("previewContainer");
      const previewItem = document.createElement("div");
      previewItem.className = "image-item mb-2 separator-horizontal";
      previewItem.textContent = "处理中...";
      previewContainer.insertBefore(previewItem, previewContainer.firstChild);
      previewContainer.classList.remove("hidden");
      try {
        const response = await fetch(editUrl, {
          method: "POST",
          headers: {
            "Authorization": "Bearer " + apiKey
            // 不要加 Content-Type，fetch 会自动设置 multipart/form-data
          },
          body: formData
        });
        if (response.ok) {
          const result = await response.json();
          const formatVal = document.getElementById("format").value;
          if (result.data && result.data.length > 0) {
            previewItem.innerHTML = "";
            result.data.forEach((item, idx) => {
              if (item.b64_json) {
                const mime = (formatVal === "jpeg" || formatVal === "webp") ? formatVal : "png";
                const imageSrc = "data:image/" + mime + ";base64," + item.b64_json;
                const img = document.createElement("img");
                img.className = "full-width";
                img.src = imageSrc;
                const caption = document.createElement("p");
                caption.textContent = prompt + (result.data.length > 1 ? ` [${idx + 1}]` : "");
                previewItem.appendChild(caption);
                previewItem.appendChild(img);
              }
            });
            if (previewItem.innerHTML === "") {
              previewItem.textContent = "返回数据中无图片数据";
            }
          } else {
            previewItem.textContent = "返回数据中无图片数据";
          }
        } else {
          const errorText = await response.text();
          console.error("详细错误信息：", errorText);
          previewItem.textContent = "请求失败，状态码：" + response.status + "，详细：" + errorText;
        }
      } catch (error) {
        console.error("请求错误详情：", error);
        previewItem.textContent = "请求出现错误：" + error;
      }
    });

    // 新增：遮罩绘制按钮可用性
    const drawMaskBtn = document.getElementById("drawMaskBtn");
    const maskUploadGroup = document.getElementById("maskUploadGroup");
    const maskCanvasContainer = document.getElementById("maskCanvasContainer");
    const maskToolbox = document.getElementById("maskToolbox");
    const downloadMaskBtn = document.getElementById("downloadMaskBtn");
    const inputImage = document.getElementById("inputImage");
    let maskCanvas = null;
    let maskCtx = null;
    let drawing = false;
    let brushShape = 'circle';
    // 默认画笔大小
    let brushSize = 30; // 直径/边长
    let maskImageData = null;
    let maskBaseImage = null;
    let isDrawingMask = false;
    let maskCursorOverlay = null;

    // 画笔工具箱事件
    document.getElementById('maskBrushShape').addEventListener('change', e => {
      brushShape = e.target.value;
    });
    document.getElementById('maskBrushSize').addEventListener('input', e => {
      brushSize = parseInt(e.target.value);
      document.getElementById('maskBrushSizeVal').textContent = brushSize;
    });

    // 监听输入图片变化，决定绘制遮罩按钮可用性
    inputImage.addEventListener('change', () => {
      drawMaskBtn.disabled = !(inputImage.files && inputImage.files.length > 0);
      if (!inputImage.files || inputImage.files.length === 0) {
        if (isDrawingMask) {
          exitDrawMaskMode();
        }
      }
    });

    // 绘制遮罩按钮逻辑
    drawMaskBtn.addEventListener('click', async () => {
      if (!isDrawingMask) {
        // 进入绘制模式
        isDrawingMask = true;
        drawMaskBtn.textContent = '放弃绘制';
        maskUploadGroup.style.display = 'none';
        maskCanvasContainer.style.display = '';
        maskToolbox.style.display = '';
        downloadMaskBtn.style.display = '';
        // 初始化画布
        await setupMaskCanvas();
      } else {
        // 退出绘制模式
        exitDrawMaskMode();
      }
    });

    function exitDrawMaskMode() {
      isDrawingMask = false;
      drawMaskBtn.textContent = '绘制遮罩';
      maskUploadGroup.style.display = '';
      maskCanvasContainer.style.display = 'none';
      maskToolbox.style.display = 'none';
      downloadMaskBtn.style.display = 'none';
      if (maskCanvasContainer.firstChild) maskCanvasContainer.removeChild(maskCanvasContainer.firstChild);
      maskCanvas = null;
      maskCtx = null;
      maskImageData = null;
      maskBaseImage = null;
    }

    // 初始化遮罩画布
    async function setupMaskCanvas() {
      // 清空容器
      maskCanvasContainer.innerHTML = '';
      maskCanvas = document.createElement('canvas');
      maskCanvas.style.border = '1px solid #ccc';
      maskCanvas.style.display = 'block';
      maskCanvas.style.position = 'relative';
      maskCanvasContainer.appendChild(maskCanvas);
      // 读取第一张图片
      const file = inputImage.files[0];
      const img = new window.Image();
      img.src = await fileToDataURL(file);
      await new Promise(res => { img.onload = res; });
      maskBaseImage = img;
      // 限制画布最大显示尺寸
      const maxDisplay = 512;
      let displayW = img.width, displayH = img.height;
      if (img.width > maxDisplay || img.height > maxDisplay) {
        if (img.width >= img.height) {
          displayW = maxDisplay;
          displayH = Math.round(img.height * maxDisplay / img.width);
        } else {
          displayH = maxDisplay;
          displayW = Math.round(img.width * maxDisplay / img.height);
        }
      }
      maskCanvas.width = img.width;
      maskCanvas.height = img.height;
      maskCanvas.style.width = displayW + 'px';
      maskCanvas.style.height = displayH + 'px';
      maskCtx = maskCanvas.getContext('2d');
      // 新建遮罩层（全不透明）
      maskImageData = maskCtx.createImageData(img.width, img.height);
      for (let i = 0; i < maskImageData.data.length; i += 4) {
        maskImageData.data[i + 3] = 255; // alpha=255
      }
      // 动态设置画笔最大值
      const maxBrushSize = Math.round(Math.max(img.width, img.height) * 1.2);
      const brushSizeInput = document.getElementById('maskBrushSize');
      brushSizeInput.max = maxBrushSize;
      // 若当前brushSize超出最大值，重置
      if (brushSize > maxBrushSize) {
        brushSize = maxBrushSize;
        brushSizeInput.value = brushSize;
        document.getElementById('maskBrushSizeVal').textContent = brushSize;
      } else {
        // 同步显示
        brushSizeInput.value = brushSize;
        document.getElementById('maskBrushSizeVal').textContent = brushSize;
      }
      // 预览光标canvas（全局唯一）
      if (!maskCursorOverlay) {
        maskCursorOverlay = document.createElement('canvas');
        maskCursorOverlay.style.position = 'absolute';
        maskCursorOverlay.style.left = '0';
        maskCursorOverlay.style.top = '0';
        maskCursorOverlay.style.pointerEvents = 'none';
        maskCanvasContainer.appendChild(maskCursorOverlay);
      } else {
        maskCanvasContainer.appendChild(maskCursorOverlay);
      }
      maskCursorOverlay.width = maskCanvas.width;
      maskCursorOverlay.height = maskCanvas.height;
      maskCursorOverlay.style.width = maskCanvas.style.width;
      maskCursorOverlay.style.height = maskCanvas.style.height;
      // 画布事件
      maskCanvas.onmousedown = e => { drawing = true; lastDrawX = lastDrawY = null; drawAt(e); };
      maskCanvas.onmouseup = () => { drawing = false; lastDrawX = lastDrawY = null; };
      maskCanvas.onmouseleave = () => { drawing = false; lastDrawX = lastDrawY = null; maskCursorOverlay.style.display = 'none'; };
      maskCanvas.onmousemove = e => {
        if (drawing) drawAt(e);
        drawCursorOverlay(e);
      };
      maskCanvas.onmouseenter = e => { maskCursorOverlay.style.display = ''; drawCursorOverlay(e); };
      // 触摸支持（不显示预览）
      maskCanvas.ontouchstart = e => { drawing = true; lastDrawX = lastDrawY = null; drawAt(e.touches[0]); e.preventDefault(); maskCursorOverlay.style.display = 'none'; };
      maskCanvas.ontouchend = () => { drawing = false; lastDrawX = lastDrawY = null; };
      maskCanvas.ontouchcancel = () => { drawing = false; lastDrawX = lastDrawY = null; };
      maskCanvas.ontouchmove = e => { if (drawing) drawAt(e.touches[0]); e.preventDefault(); maskCursorOverlay.style.display = 'none'; };
      // 预览光标绘制函数
      function drawCursorOverlay(e) {
        const rect = maskCanvas.getBoundingClientRect();
        const x = Math.round((e.clientX - rect.left) * maskCanvas.width / rect.width);
        const y = Math.round((e.clientY - rect.top) * maskCanvas.height / rect.height);
        const ctx = maskCursorOverlay.getContext('2d');
        ctx.clearRect(0, 0, maskCursorOverlay.width, maskCursorOverlay.height);
        ctx.save();
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#fff';
        ctx.shadowColor = '#000';
        ctx.shadowBlur = 0;
        ctx.beginPath();
        const half = brushSize / 2;
        if (brushShape === 'circle') {
          ctx.arc(x, y, half, 0, 2 * Math.PI);
        } else {
          ctx.rect(x - half, y - half, brushSize, brushSize);
        }
        ctx.stroke();
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#000';
        ctx.shadowColor = 'transparent';
        ctx.beginPath();
        if (brushShape === 'circle') {
          ctx.arc(x, y, half, 0, 2 * Math.PI);
        } else {
          ctx.rect(x - half, y - half, brushSize, brushSize);
        }
        ctx.stroke();
        ctx.restore();
      }
      // 初始渲染
      renderMaskCanvas();
    }
    function renderMaskCanvas() {
      // 先画底图
      maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
      maskCtx.drawImage(maskBaseImage, 0, 0, maskCanvas.width, maskCanvas.height);
      // 用离屏canvas生成红色遮罩层
      const maskVisCanvas = document.createElement('canvas');
      maskVisCanvas.width = maskImageData.width;
      maskVisCanvas.height = maskImageData.height;
      const visCtx = maskVisCanvas.getContext('2d');
      const visImg = visCtx.createImageData(maskImageData.width, maskImageData.height);
      for (let i = 0; i < maskImageData.data.length; i += 4) {
        if (maskImageData.data[i + 3] === 0) {
          visImg.data[i] = 255; visImg.data[i + 1] = 0; visImg.data[i + 2] = 0; visImg.data[i + 3] = 100; // 红色半透明
        } else {
          visImg.data[i + 3] = 0;
        }
      }
      visCtx.putImageData(visImg, 0, 0);
      maskCtx.drawImage(maskVisCanvas, 0, 0, maskCanvas.width, maskCanvas.height);
    }
    // 下载遮罩
    downloadMaskBtn.addEventListener('click', () => {
      if (!maskCanvas || !maskImageData) return;
      // 只导出alpha通道，黑底透明
      const exportCanvas = document.createElement('canvas');
      exportCanvas.width = maskImageData.width;
      exportCanvas.height = maskImageData.height;
      const exportCtx = exportCanvas.getContext('2d');
      const imgData = exportCtx.createImageData(maskImageData.width, maskImageData.height);
      for (let i = 0; i < maskImageData.data.length; i += 4) {
        imgData.data[i] = 0;
        imgData.data[i + 1] = 0;
        imgData.data[i + 2] = 0;
        imgData.data[i + 3] = maskImageData.data[i + 3];
      }
      exportCtx.putImageData(imgData, 0, 0);
      exportCanvas.toBlob(blob => {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'mask.png';
        a.click();
      }, 'image/png');
    });
    // 退出绘制模式时，恢复遮罩上传
    document.getElementById("maskImage").addEventListener('change', () => {
      if (isDrawingMask) {
        exitDrawMaskMode();
      }
    });
  </script>
</body>

</html>