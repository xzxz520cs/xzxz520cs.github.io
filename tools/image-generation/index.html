<!DOCTYPE html>
<html lang="zh-cn">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="gpt-image-1 API å›¾åƒç”Ÿæˆè°ƒç”¨å·¥å…·ï¼ˆéœ€è‡ªå¤‡ API KEYï¼‰">
  <meta name="keywords" content="gpt-image-1, å›¾åƒç”Ÿæˆ, API, å·¥å…·">
  <title>gpt-image-1 API å›¾åƒç”Ÿæˆè°ƒç”¨å·¥å…· - å¤©å¤©å‘è›‹ç³•çš„å·¥å…·ç®±</title>
  <link rel="stylesheet" href="../../assets/css/styles.css">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-HYJXFSRHF5"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-HYJXFSRHF5');
  </script>
</head>

<body>
  <!-- æ¨¡æ¿é¡µå¤´ -->
  <header class="site-header">
    <div class="container">
      <div class="site-title">
        <a href="/" class="site-title-link">
          <span class="site-title">å¤©å¤©å‘è›‹ç³•çš„å·¥å…·ç®±</span>
        </a>
      </div>
      <label for="menu-toggle-checkbox" class="menu-toggle" aria-label="æ‰“å¼€èœå•">â˜°</label>
      <nav class="nav-menu">
        <ul class="nav-list">
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" aria-haspopup="true" aria-expanded="false">å·¥å…·</a>
            <ul class="dropdown-menu">
              <li><a href="/tools/yu-gi-oh-probability-calculator/" class="dropdown-item">æ¸¸æˆç‹æ¦‚ç‡è®¡ç®—å™¨</a></li>
              <li><a href="/tools/card-translate/" class="dropdown-item">æ¸¸æˆç‹å¡ç‰Œæ—¥ä¸­å¯¹ç…§æ–‡æœ¬ç”Ÿæˆå™¨</a></li>
              <li><a href="/tools/webp-avif-2-jpg-png/" class="dropdown-item">AVIF/WebPè½¬JPG/PNG</a></li>
              <li><a href="https://chromewebstore.google.com/detail/kmnmkpgmneeokldcmfcgjppgpcfecoed"
                  class="dropdown-item">æ¢å¤å…³é—­çš„æ ‡ç­¾é¡µ</a></li>
            </ul>
          </li>
        </ul>
      </nav>
    </div>
    <input type="checkbox" id="menu-toggle-checkbox" hidden>
    <div class="drawer">
      <div class="container">
        <label for="menu-toggle-checkbox" class="menu-toggle close-menu" aria-label="å…³é—­èœå•">Ã—</label>
      </div>
      <nav class="drawer-menu">
        <ul class="drawer-list">
          <li class="drawer-item">
            <a href="#" class="drawer-link">å·¥å…·</a>
            <ul class="drawer-submenu">
              <li><a href="/tools/yu-gi-oh-probability-calculator/" class="drawer-subitem">æ¸¸æˆç‹æ¦‚ç‡è®¡ç®—å™¨</a></li>
              <li><a href="/tools/card-translate/" class="drawer-subitem">æ¸¸æˆç‹å¡ç‰Œæ—¥ä¸­å¯¹ç…§æ–‡æœ¬ç”Ÿæˆå™¨</a></li>
              <li><a href="/tools/webp-avif-2-jpg-png/" class="drawer-subitem">AVIF/WebPè½¬JPG/PNG</a></li>
              <li><a href="https://chromewebstore.google.com/detail/kmnmkpgmneeokldcmfcgjppgpcfecoed"
                  class="drawer-subitem">æ¢å¤å…³é—­çš„æ ‡ç­¾é¡µ</a></li>
            </ul>
          </li>
        </ul>
      </nav>
    </div>
    <label for="menu-toggle-checkbox" class="drawer-overlay"></label>
  </header>

  <!-- ä¸»å†…å®¹åŒºåŸŸ -->
  <main class="container">
    <h1 class="mt-0 mb-3">gpt-image-1 API å›¾åƒç”Ÿæˆè°ƒç”¨å·¥å…·</h1>
    <div class="card card--elevated">
      <div class="form-group mt-2">
        <label for="apiKey">API Key</label>
        <input type="text" id="apiKey" placeholder="è¯·è¾“å…¥ä½ çš„ API Keyï¼ˆè¯·è‡ªå¤‡ï¼‰" name="apiKey" autocomplete="on"
          class="form-control">
      </div>
      <div class="form-group mt-2">
        <label for="apiUrl">API URL</label>
        <input type="text" id="apiUrl" placeholder="è¯·è¾“å…¥ä½ çš„ API URLå¦‚https://api.example.com" name="apiUrl"
          class="form-control">
      </div>
      <!-- å›ºå®šæ¨¡å‹ä¸º gpt-image-1 -->
      <div class="form-group mt-2">
        <label>æ¨¡å‹</label>
        <input type="text" value="gpt-image-1" class="form-control" readonly>
      </div>
      <div class="form-group mt-2">
        <label for="prompt">æç¤ºè¯­</label>
        <textarea id="prompt" placeholder="è¯·è¾“å…¥ç”Ÿæˆå›¾åƒçš„æç¤ºè¯­" class="form-control" maxlength="1024" rows="3"></textarea>
      </div>
      <!-- æ–°å¢ï¼šç”Ÿæˆæ•°é‡ -->
      <div class="form-group mt-2">
        <label for="n">ç”Ÿæˆæ•°é‡</label>
        <input type="number" id="n" class="form-control" min="1" value="1">
      </div>
      <!-- æ–°å¢ï¼šä¸Šä¼ ç¬¬ä¸€ä¸ªå›¾åƒï¼ˆé®ç½©ä¼šåº”ç”¨åœ¨è¿™ä¸ªå›¾åƒï¼‰ -->
      <div class="form-group mt-2">
        <label for="firstInputImage">ä¸Šä¼ ç¬¬ä¸€ä¸ªå›¾åƒï¼ˆé®ç½©ä¼šåº”ç”¨åœ¨è¿™ä¸ªå›¾åƒï¼‰</label>
        <input type="file" id="firstInputImage" class="form-control" accept="image/*">
      </div>
      <!-- æ–°å¢ï¼šä¸Šä¼ å¤šä¸ªå›¾åƒï¼ˆå¯å¤šé€‰ï¼‰ -->
      <div class="form-group mt-2">
        <label for="multiInputImage">ä¸Šä¼ å¤šä¸ªå›¾åƒ</label>
        <input type="file" id="multiInputImage" class="form-control" accept="image/*" multiple>
      </div>
      <!-- æ–°å¢ï¼šç»˜åˆ¶é®ç½©ç›¸å…³æŒ‰é’®ã€ç”»å¸ƒå®¹å™¨å’Œå·¥å…·ç®± -->
      <div class="form-group mt-2" id="drawMaskGroup">
        <button id="drawMaskBtn" class="btn btn--secondary disabled" type="button">ç»˜åˆ¶é®ç½©</button>
        <button id="downloadMaskBtn" class="btn btn--secondary hidden" type="button">ä¸‹è½½é®ç½©</button>
        <p class="text-muted mt-3">æç¤ºï¼šé®ç½©åŒºåŸŸ(çº¢è‰²/ä¸é€æ˜)è¡¨ç¤ºéœ€è¦ä¿ç•™ä¸è¢«ä¿®æ”¹çš„éƒ¨åˆ†ï¼Œéé®ç½©åŒºåŸŸï¼ˆé€æ˜åŒºåŸŸï¼‰å°†è¢«AIä¿®æ”¹</p>
        <div id="maskToolbox" class="hidden mt-3 flex">
            <div class="tool-buttons flex gap-1">
              <button id="brushModeBtn" class="btn btn--toggle active" type="button" title="ç”»ç¬”">
                ğŸ–Œï¸
              </button>
              <button id="eraserModeBtn" class="btn btn--toggle" type="button" title="æ©¡çš®æ“¦">
                ğŸ§½
              </button>
              <button id="circleBrushBtn" class="btn btn--toggle active" type="button" title="åœ†å½¢ç”»ç¬”">
                âšª
              </button>
              <button id="squareBrushBtn" class="btn btn--toggle" type="button" title="æ–¹å½¢ç”»ç¬”">
                â¬œ
              </button>
            </div>
            <div class="brush-size-control">
              <label>ç”»ç¬”å¤§å°:
                <input type="range" id="maskBrushSize" min="5" max="100" value="30">
                <span id="maskBrushSizeVal">30</span>px
              </label>
            </div>
          </div>
          <div id="maskCanvasContainer" class="hidden relative-position mt-3 flex">
          <!-- ç”»å¸ƒå’Œé¢„è§ˆå…‰æ ‡canvaséƒ½æ”¾è¿™é‡Œ -->
        </div>
      </div>
      <!-- æ–°å¢ï¼šé®ç½©ä¸Šä¼ ï¼ˆç”¨äºç¼–è¾‘æ—¶å±€éƒ¨ä¿®æ”¹ï¼‰ -->
      <div class="form-group mt-2" id="maskUploadGroup">
        <label for="maskImage">ä¸Šä¼ é®ç½©å›¾åƒï¼ˆé€‰å¡«ï¼‰</label>
        <input type="file" id="maskImage" class="form-control" accept="image/*">
      </div>
      <!-- å¯é€‰ï¼šå›¾åƒå°ºå¯¸ -->
      <div class="form-group mt-2">
        <label for="size">å›¾åƒå°ºå¯¸</label>
        <select id="size" class="form-control">
          <option value="1024x1024" selected>1024x1024ï¼ˆé»˜è®¤ï¼‰</option>
          <option value="1024x1536">1024x1536ï¼ˆç«–å±ï¼‰</option>
          <option value="1536x1024">1536x1024ï¼ˆæ¨ªå±ï¼‰</option>
          <option value="auto">auto</option>
        </select>
      </div>
      <!-- æ–°å¢ï¼šå›¾åƒè´¨é‡è®¾ç½® -->
      <div class="form-group mt-2">
        <label for="quality">å›¾åƒè´¨é‡</label>
        <select id="quality" class="form-control">
          <option value="low">ä½</option>
          <option value="medium">ä¸­</option>
          <option value="high">é«˜</option>
          <option value="auto" selected>auto</option>
        </select>
      </div>
      <!-- æ–°å¢ï¼šè¾“å‡ºæ ¼å¼ -->
      <div class="form-group mt-2">
        <label for="format">è¾“å‡ºæ ¼å¼</label>
        <select id="format" class="form-control">
          <option value="png" selected>PNG</option>
          <option value="jpeg">JPEG</option>
          <option value="webp">WEBP</option>
        </select>
      </div>
      <!-- æ–°å¢ï¼šèƒŒæ™¯è®¾ç½® -->
      <div class="form-group mt-2">
        <label for="background">èƒŒæ™¯</label>
        <select id="background" class="form-control">
          <option value="opaque" selected>ä¸é€æ˜</option>
          <option value="transparent">é€æ˜</option>
        </select>
      </div>
      <!-- æ–°å¢ï¼šå‹ç¼©ç‡ (ä»…åœ¨JPEG/WebPæ—¶ç”Ÿæ•ˆ) -->
      <div class="form-group mt-2">
        <label for="compression">å‹ç¼©ç‡ (0-100) 0ä¸ºæ— æŸ</label>
        <input type="number" id="compression" placeholder="è¯·è¾“å…¥å‹ç¼©ç‡" class="form-control" min="0" max="100" value="0">
      </div>
      <!-- æ–°å¢ï¼šå†…å®¹å®¡æ ¸ -->
      <div class="form-group mt-2">
        <label for="moderation">å†…å®¹å®¡æ ¸</label>
        <select id="moderation" class="form-control">
          <option value="auto" selected>auto</option>
          <option value="low">low</option>
        </select>
      </div>
      <div class="form-group mt-3">
        <button id="generateBtn" class="btn btn--primary">ç”Ÿæˆå›¾åƒ</button>
        <button id="editBtn" class="btn btn--tertiary">ç¼–è¾‘å›¾åƒ</button>
        <button id="clearPreviewBtn" class="btn btn--secondary">æ¸…ç©ºé¢„è§ˆ</button>
      </div>
      <div id="previewContainer" class="hidden mt-2"></div>
    </div>
  </main>

  <!-- æ¨¡æ¿é¡µè„š -->
  <footer class="site-footer">
    <div class="container">
      <div class="footer-grid">
        <div>
          <h3 class="footer-title">å…³äºä½œè€…</h3>
          <ul class="footer-links">
            <li><a href="mailto:ttfdg520cs@gmail.com">ttfdg520cs@gmail.com</a></li>
            <li><a href="https://space.bilibili.com/1446349" target="_blank">Bilibiliä¸»é¡µ</a></li>
            <li><a href="https://github.com/xzxz520cs" target="_blank">GitHub</a></li>
          </ul>
        </div>
      </div>
      <div class="footer-bottom">
        <p class="text-muted">Â© 2025 å¤©å¤©å‘è›‹ç³•çš„å·¥å…·ç®±</p>
      </div>
    </div>
  </footer>

  <!-- è„šæœ¬éƒ¨åˆ† -->
  <script>
    // ç”»ç¬”æ¨¡å¼æŒ‰é’®äº‹ä»¶
    document.getElementById('brushModeBtn').addEventListener('click', () => {
      maskToolMode = 'brush';
      document.getElementById('brushModeBtn').classList.add('active');
      document.getElementById('eraserModeBtn').classList.remove('active');
    });

    document.getElementById('eraserModeBtn').addEventListener('click', () => {
      maskToolMode = 'eraser';
      document.getElementById('eraserModeBtn').classList.add('active');
      document.getElementById('brushModeBtn').classList.remove('active');
    });

    // ç”»ç¬”å½¢çŠ¶æŒ‰é’®äº‹ä»¶
    document.getElementById('circleBrushBtn').addEventListener('click', () => {
      brushShape = 'circle';
      document.getElementById('circleBrushBtn').classList.add('active');
      document.getElementById('squareBrushBtn').classList.remove('active');
    });

    document.getElementById('squareBrushBtn').addEventListener('click', () => {
      brushShape = 'square';
      document.getElementById('squareBrushBtn').classList.add('active');
      document.getElementById('circleBrushBtn').classList.remove('active');
    });

    // åˆå§‹åŒ–ï¼šåŠ è½½å¹¶ä¿å­˜ API Key å’Œ API URL åˆ° localStorage
    document.addEventListener('DOMContentLoaded', () => {
      // åŠ è½½ API Key å’Œ API URL
      const apiKeyInput = document.getElementById("apiKey");
      const apiUrlInput = document.getElementById("apiUrl");
      if (localStorage.getItem("image_apiKey")) {
        apiKeyInput.value = localStorage.getItem("image_apiKey");
      }
      if (localStorage.getItem("image_apiUrl")) {
        apiUrlInput.value = localStorage.getItem("image_apiUrl");
      }
      apiKeyInput.addEventListener("input", () => {
        localStorage.setItem("image_apiKey", apiKeyInput.value.trim());
      });
      apiUrlInput.addEventListener("input", () => {
        localStorage.setItem("image_apiUrl", apiUrlInput.value.trim());
      });

      // æ–°å¢ï¼šåŠ è½½å¹¶ä¿å­˜å…¶å®ƒè®¾ç½®
      const nInput = document.getElementById("n");
      if (localStorage.getItem("image_n")) {
        nInput.value = localStorage.getItem("image_n");
      }
      nInput.addEventListener("input", () => {
        localStorage.setItem("image_n", nInput.value);
      });

      const sizeSelect = document.getElementById("size");
      if (localStorage.getItem("image_size")) {
        sizeSelect.value = localStorage.getItem("image_size");
      }
      sizeSelect.addEventListener("change", () => {
        localStorage.setItem("image_size", sizeSelect.value);
      });

      const qualitySelect = document.getElementById("quality");
      if (localStorage.getItem("image_quality")) {
        qualitySelect.value = localStorage.getItem("image_quality");
      }
      qualitySelect.addEventListener("change", () => {
        localStorage.setItem("image_quality", qualitySelect.value);
      });

      const formatSelect = document.getElementById("format");
      if (localStorage.getItem("image_format")) {
        formatSelect.value = localStorage.getItem("image_format");
      }
      formatSelect.addEventListener("change", () => {
        localStorage.setItem("image_format", formatSelect.value);
      });

      const backgroundSelect = document.getElementById("background");
      if (localStorage.getItem("image_background")) {
        backgroundSelect.value = localStorage.getItem("image_background");
      }
      backgroundSelect.addEventListener("change", () => {
        localStorage.setItem("image_background", backgroundSelect.value);
      });

      const compressionInput = document.getElementById("compression");
      if (localStorage.getItem("image_compression")) {
        compressionInput.value = localStorage.getItem("image_compression");
      }
      compressionInput.addEventListener("input", () => {
        localStorage.setItem("image_compression", compressionInput.value);
      });

      const moderationSelect = document.getElementById("moderation");
      if (localStorage.getItem("image_moderation")) {
        moderationSelect.value = localStorage.getItem("image_moderation");
      }
      moderationSelect.addEventListener("change", () => {
        localStorage.setItem("image_moderation", moderationSelect.value);
      });
    });

    // å›¾ç‰‡ä¸Šä¼ å¤„ç†ï¼šä½¿ç”¨ FileReader å°†ä¸Šä¼ æ–‡ä»¶è½¬æ¢ä¸º Base64 å­—ç¬¦ä¸²
    function fileToDataURL(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(new Error("æ–‡ä»¶è¯»å–å¤±è´¥"));
        reader.readAsDataURL(file);
      });
    }

    // å°†æ–‡ä»¶è½¬æ¢ä¸ºPNGæ ¼å¼çš„Blobå¯¹è±¡
    function fileToPngBlob(file, targetWidth = 0, targetHeight = 0) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        const reader = new FileReader();
        
        reader.onload = (e) => {
          img.onload = () => {
            const canvas = document.createElement('canvas');
            // å¦‚æœæŒ‡å®šäº†ç›®æ ‡å°ºå¯¸åˆ™ä½¿ç”¨ï¼Œå¦åˆ™ä½¿ç”¨åŸå›¾å°ºå¯¸
            canvas.width = targetWidth > 0 ? targetWidth : img.width;
            canvas.height = targetHeight > 0 ? targetHeight : img.height;
            
            const ctx = canvas.getContext('2d');
            // é«˜è´¨é‡ç¼©æ”¾
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            
            canvas.toBlob((blob) => {
              if (blob) {
                resolve(blob);
              } else {
                reject(new Error('Canvasè½¬Blobå¤±è´¥'));
              }
            }, 'image/png');
          };
          img.onerror = () => reject(new Error('å›¾ç‰‡åŠ è½½å¤±è´¥'));
          img.src = e.target.result;
        };
        reader.onerror = () => reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥'));
        reader.readAsDataURL(file);
      });
    }

    // ç”»ç¬”ç»˜åˆ¶å‡½æ•°ï¼Œéœ€æ”¾åœ¨setupMaskCanvaså‰
    let maskToolMode = 'brush';
    let lastDrawX = null, lastDrawY = null;
    function drawAt(e) {
      const rect = maskCanvas.getBoundingClientRect();
      // è®¡ç®—ç”»å¸ƒä¸Šçš„åæ ‡(å·²è€ƒè™‘ç¼©æ”¾)
      const x = Math.round((e.clientX - rect.left) * maskCanvas.width / rect.width);
      const y = Math.round((e.clientY - rect.top) * maskCanvas.height / rect.height);

      // ç›´æ¥ç»˜åˆ¶å½“å‰ç‚¹
      drawDot(x, y);

      lastDrawX = x;
      lastDrawY = y;
      renderMaskCanvas();
    }
    function drawDot(x, y) {
      const half = Math.floor(brushSize / 2);
      if (brushShape === 'circle') {
        for (let dx = -half; dx <= half; dx++) {
          for (let dy = -half; dy <= half; dy++) {
            if (dx * dx + dy * dy <= half * half) {
              const px = x + dx, py = y + dy;
              if (px >= 0 && px < maskImageData.width && py >= 0 && py < maskImageData.height) {
                const idx = (py * maskImageData.width + px) * 4 + 3;
                maskImageData.data[idx] = (maskToolMode === 'brush') ? 0 : 255;
              }
            }
          }
        }
      } else {
        for (let dx = -half; dx <= half; dx++) {
          for (let dy = -half; dy <= half; dy++) {
            const px = x + dx, py = y + dy;
            if (px >= 0 && px < maskImageData.width && py >= 0 && py < maskImageData.height) {
              const idx = (py * maskImageData.width + px) * 4 + 3;
              maskImageData.data[idx] = (maskToolMode === 'brush') ? 0 : 255;
            }
          }
        }
      }
    }

    // ç”Ÿæˆå›¾åƒé€»è¾‘
    document.getElementById("generateBtn").addEventListener("click", async () => {
      const apiKey = document.getElementById("apiKey").value.trim();
      const apiUrl = document.getElementById("apiUrl").value.trim();
      const prompt = document.getElementById("prompt").value.trim();
      const n = parseInt(document.getElementById("n").value) || 1;
      const size = document.getElementById("size").value;
      const quality = document.getElementById("quality").value;
      const formatVal = document.getElementById("format").value;
      const background = document.getElementById("background").value;
      const compression = document.getElementById("compression").value;
      const moderation = document.getElementById("moderation").value;

      if (!apiKey || !apiUrl || !prompt) {
        alert("è¯·è¾“å…¥ API Keyã€API URL å’Œæç¤ºè¯­ï¼");
        return;
      }

      const generateBtn = document.getElementById("generateBtn");
      generateBtn.disabled = true;
      generateBtn.classList.add('disabled');

      const previewContainer = document.getElementById("previewContainer");
      // æ˜¾ç¤ºå ä½ä¿¡æ¯
      const previewItem = document.createElement("div");
      previewItem.className = "image-item mb-2 separator-horizontal";
      previewItem.textContent = "å¤„ç†ä¸­...";
      previewContainer.insertBefore(previewItem, previewContainer.firstChild);
      previewContainer.classList.remove("hidden");

      const data = {
        model: "gpt-image-1",
        prompt: prompt,
        n: n,
        size: size,
        quality: quality,
        output_format: formatVal,
        background: background,
        moderation: moderation
      };

      if ((formatVal === "jpeg" || formatVal === "webp") && compression && parseInt(compression) > 0) {
        data.output_compression = parseInt(compression);
      }

      // æ–°å¢ï¼šå¤„ç†ä¸Šä¼ çš„è¾“å…¥å›¾åƒï¼ˆå¦‚æœå­˜åœ¨ï¼‰
      const imageFileInput = document.getElementById("multiInputImage");
      if (imageFileInput.files && imageFileInput.files.length > 0) {
        try {
          // å…ˆè·å–ç¬¬ä¸€å¼ å›¾ç‰‡çš„å®½é«˜
          let targetWidth = 0, targetHeight = 0;
          {
            const imgProbe = new window.Image();
            const probeUrl = await fileToDataURL(imageFileInput.files[0]);
            await new Promise((res, rej) => {
              imgProbe.onload = res;
              imgProbe.onerror = rej;
              imgProbe.src = probeUrl;
            });
            targetWidth = imgProbe.width;
            targetHeight = imgProbe.height;
          }
          if (imageFileInput.files.length === 1) {
            // å•å¼ å›¾ç‰‡ï¼Œè½¬ä¸º PNG DataURL
            const pngBlob = await fileToPngBlob(imageFileInput.files[0], targetWidth, targetHeight);
            const base64Image = await fileToDataURL(pngBlob);
            data.input_image = base64Image;
          } else {
            // å¤šå¼ å›¾ç‰‡ï¼Œå…¨éƒ¨è½¬ä¸º PNG DataURL
            const base64Images = [];
            for (let i = 0; i < imageFileInput.files.length; i++) {
              const pngBlob = await fileToPngBlob(imageFileInput.files[i], targetWidth, targetHeight);
              base64Images.push(await fileToDataURL(pngBlob));
            }
            data.input_images = base64Images;
          }
        } catch (e) {
          console.error(e);
          alert("è¯»å–ä¸Šä¼ çš„å›¾åƒå¤±è´¥ï¼");
          return;
        }
      }

      const baseUrl = apiUrl.replace(/\/+$/, "");
      const generationUrl = baseUrl + "/v1/images/generations";

      try {
        const response = await fetch(generationUrl, {
          method: "POST",
          headers: {
            "Authorization": "Bearer " + apiKey,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(data)
        });

        if (response.ok) {
          const result = await response.json();
          // æå–é™¤å›¾ç‰‡æ•°æ®ä»¥å¤–çš„ä¿¡æ¯å¹¶æ‰“å°åˆ°æ§åˆ¶å°
          const { data, ...otherInfo } = result;
          console.log("APIè¿”å›å†…å®¹(é™¤å›¾ç‰‡æ•°æ®):", otherInfo);
          if (data && data.length > 0) {
            previewItem.innerHTML = "";
            data.forEach((item, idx) => {
              if (item.b64_json) {
                const mime = (formatVal === "jpeg" || formatVal === "webp") ? formatVal : "png";
                const imageSrc = "data:image/" + mime + ";base64," + item.b64_json;
                const img = document.createElement("img");
                img.className = "full-width";
                img.src = imageSrc;
                const caption = document.createElement("p");
                caption.textContent = prompt + (data.length > 1 ? ` [${idx + 1}]` : "");
                previewItem.appendChild(caption);
                previewItem.appendChild(img);
              }
            });
            if (previewItem.innerHTML === "") {
              previewItem.textContent = "è¿”å›æ•°æ®ä¸­æ— å›¾ç‰‡æ•°æ®";
            }
          } else {
            previewItem.textContent = "è¿”å›æ•°æ®ä¸­æ— å›¾ç‰‡æ•°æ®";
          }
        } else {
          const errorText = await response.text();
          console.error("è¯¦ç»†é”™è¯¯ä¿¡æ¯ï¼š", errorText);
          previewItem.textContent = "è¯·æ±‚å¤±è´¥ï¼ŒçŠ¶æ€ç ï¼š" + response.status + "ï¼Œè¯¦ç»†ï¼š" + errorText;
        }
      } catch (error) {
        console.error("è¯·æ±‚é”™è¯¯è¯¦æƒ…ï¼š", error);
        previewItem.textContent = "è¯·æ±‚å‡ºç°é”™è¯¯ï¼š" + error;
      } finally {
        const generateBtn = document.getElementById("generateBtn");
        generateBtn.disabled = false;
        generateBtn.classList.remove('disabled');
      }
    });

    // æ¸…ç©ºé¢„è§ˆé€»è¾‘
    document.getElementById("clearPreviewBtn").addEventListener("click", () => {
      const previewContainer = document.getElementById("previewContainer");
      previewContainer.innerHTML = "";
      previewContainer.classList.add("hidden");
    });

    // ç¼–è¾‘å›¾åƒé€»è¾‘
    document.getElementById("editBtn").addEventListener("click", async () => {
      const apiKey = document.getElementById("apiKey").value.trim();
      const apiUrl = document.getElementById("apiUrl").value.trim();
      const prompt = document.getElementById("prompt").value.trim();
      const n = parseInt(document.getElementById("n").value) || 1;
      const size = document.getElementById("size").value || "1024x1024";
      const quality = document.getElementById("quality").value || "auto";
      const maskInput = document.getElementById("maskImage");
      // æ–°å¢ï¼šé®ç½©ç»˜åˆ¶æ¨¡å¼åˆ¤æ–­
      const isDrawingMask = document.getElementById('drawMaskBtn').textContent === 'æ”¾å¼ƒç»˜åˆ¶';
      if (!apiKey || !apiUrl || !prompt) {
        alert("è¯·è¾“å…¥ API Keyã€API URL å’Œæç¤ºè¯­ï¼");
        return;
      }
      const editBtn = document.getElementById("editBtn");
      editBtn.disabled = true;
      editBtn.classList.add('disabled');
      // åˆå¹¶æ‰€æœ‰ä¸Šä¼ å›¾ç‰‡ï¼ŒfirstInputImageä¼˜å…ˆ
      let files = [];
      if (firstInputImage.files && firstInputImage.files.length > 0) {
        files.push(firstInputImage.files[0]);
      }
      if (multiInputImage.files && multiInputImage.files.length > 0) {
        for (let i = 0; i < multiInputImage.files.length; i++) {
          // é¿å…é‡å¤æ·»åŠ firstInputImage
          if (!firstInputImage.files.length || multiInputImage.files[i] !== firstInputImage.files[0]) {
            files.push(multiInputImage.files[i]);
          }
        }
      }
      if (files.length === 0) {
        alert("è¯·ä¸Šä¼ è¦ç¼–è¾‘çš„å›¾åƒï¼");
        editBtn.disabled = false;
        editBtn.classList.remove('disabled');
        return;
      }
      if (files.length > 16) {
        alert("æœ€å¤šåªèƒ½ä¸Šä¼ 16å¼ å›¾ç‰‡ï¼");
        editBtn.disabled = false;
        editBtn.classList.remove('disabled');
        return;
      }
      // ç»Ÿä¸€æ‰€æœ‰å›¾ç‰‡ä¸º PNG ä¸”å°ºå¯¸ä¸ç¬¬ä¸€å¼ å›¾ä¸€è‡´
      const formData = new FormData();
      formData.append("model", "gpt-image-1");
      formData.append("prompt", prompt);
      formData.append("n", n);
      formData.append("size", size);
      formData.append("quality", quality);

      // è·å–ç›®æ ‡å°ºå¯¸ï¼ˆç¬¬ä¸€å¼ å›¾ï¼‰
      let targetWidth = 0, targetHeight = 0;
      {
        const imgProbe = new window.Image();
        const probeUrl = await fileToDataURL(files[0]);
        await new Promise((res, rej) => {
          imgProbe.onload = res;
          imgProbe.onerror = rej;
          imgProbe.src = probeUrl;
        });
        targetWidth = imgProbe.width;
        targetHeight = imgProbe.height;
      }

      // æ‰€æœ‰å›¾ç‰‡è½¬ä¸º PNG Blob å¹¶ append
      for (let i = 0; i < files.length; i++) {
        const pngBlob = await fileToPngBlob(files[i], targetWidth, targetHeight);
        formData.append("image[]", pngBlob, "image" + (i + 1) + ".png");
      }

      // é®ç½©å¤„ç†ï¼šä¼˜å…ˆç”¨ç»˜åˆ¶çš„é®ç½©
      if (isDrawingMask && window.maskImageData && window.maskCanvas) {
        // å¯¼å‡ºé®ç½©ä¸ºPNG Blobï¼ˆå·²ä¿è¯å°ºå¯¸ä¸€è‡´ï¼‰
        const exportCanvas = document.createElement('canvas');
        exportCanvas.width = maskBaseImage.width;
        exportCanvas.height = maskBaseImage.height;
        const exportCtx = exportCanvas.getContext('2d');
        
        // åˆ›å»ºä¸ç»˜åˆ¶å°ºå¯¸ç›¸åŒçš„ä¸´æ—¶ç”»å¸ƒ
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = window.maskImageData.width;
        tempCanvas.height = window.maskImageData.height;
        const tempCtx = tempCanvas.getContext('2d');
        
        // åˆ›å»ºä¸ç»˜åˆ¶å°ºå¯¸ç›¸åŒçš„ImageDataï¼Œä¿®æ­£alphaé€šé“ä¸º255-åŸå€¼
        const tempImgData = tempCtx.createImageData(window.maskImageData.width, window.maskImageData.height);
        for (let i = 0; i < window.maskImageData.data.length; i += 4) {
          tempImgData.data[i] = 0;
          tempImgData.data[i + 1] = 0;
          tempImgData.data[i + 2] = 0;
          tempImgData.data[i + 3] = 255 - window.maskImageData.data[i + 3]; // åè½¬alpha
        }
        tempCtx.putImageData(tempImgData, 0, 0);
        
        // ä½¿ç”¨é«˜è´¨é‡ç¼©æ”¾å°†ä¸´æ—¶ç”»å¸ƒæ‹‰ä¼¸åˆ°åŸå›¾å°ºå¯¸
        exportCtx.imageSmoothingEnabled = true;
        exportCtx.imageSmoothingQuality = 'high';
        exportCtx.drawImage(tempCanvas, 0, 0, maskBaseImage.width, maskBaseImage.height);
        // ä¿®æ­£ï¼šæ‹‰ä¼¸åå†äºŒå€¼åŒ–alphaé€šé“ï¼Œç¡®ä¿åªæœ‰0/255
        const exportImgData = exportCtx.getImageData(0, 0, exportCanvas.width, exportCanvas.height);
        for (let i = 0; i < exportImgData.data.length; i += 4) {
          exportImgData.data[i] = 0;
          exportImgData.data[i + 1] = 0;
          exportImgData.data[i + 2] = 0;
          exportImgData.data[i + 3] = exportImgData.data[i + 3] > 127 ? 255 : 0;
        }
        exportCtx.putImageData(exportImgData, 0, 0);
        // toBlobä¸ºå¼‚æ­¥
        await new Promise((resolve, reject) => {
          exportCanvas.toBlob(blob => {
            if (blob) {
              formData.append("mask", blob, "mask.png");
              resolve();
            } else {
              alert("é®ç½©å¯¼å‡ºå¤±è´¥");
              reject();
            }
          }, 'image/png');
        });
      } else if (maskInput.files && maskInput.files.length > 0) {
        // é®ç½©ä¸Šä¼ ä¹Ÿè½¬ä¸º PNG ä¸”å°ºå¯¸ä¸ç¬¬ä¸€å¼ å›¾ä¸€è‡´
        // éœ€è¦ä¿®æ­£alphaé€šé“ä¸º255-åŸå€¼
        const maskPngBlob = await fileToPngBlob(maskInput.files[0], targetWidth, targetHeight);
        // è¯»å–blobä¸ºImageDataï¼Œåè½¬alphaåå†å¯¼å‡º
        const maskImg = new window.Image();
        maskImg.src = await fileToDataURL(maskPngBlob);
        await new Promise(res => { maskImg.onload = res; });
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = maskImg.width;
        tempCanvas.height = maskImg.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(maskImg, 0, 0);
        const imgData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        for (let i = 0; i < imgData.data.length; i += 4) {
          imgData.data[i + 3] = 255 - imgData.data[i + 3];
        }
        tempCtx.putImageData(imgData, 0, 0);
        await new Promise((resolve, reject) => {
          tempCanvas.toBlob(blob => {
            if (blob) {
              formData.append("mask", blob, "mask.png");
              resolve();
            } else {
              alert("é®ç½©å¯¼å‡ºå¤±è´¥");
              reject();
            }
          }, 'image/png');
        });
      }
      const baseUrl = apiUrl.replace(/\/+/g, "");
      const editUrl = baseUrl + "/v1/images/edits";
      const previewContainer = document.getElementById("previewContainer");
      const previewItem = document.createElement("div");
      previewItem.className = "image-item mb-2 separator-horizontal";
      previewItem.textContent = "å¤„ç†ä¸­...";
      previewContainer.insertBefore(previewItem, previewContainer.firstChild);
      previewContainer.classList.remove("hidden");
      try {
        const response = await fetch(editUrl, {
          method: "POST",
          headers: {
            "Authorization": "Bearer " + apiKey
            // ä¸è¦åŠ  Content-Typeï¼Œfetch ä¼šè‡ªåŠ¨è®¾ç½® multipart/form-data
          },
          body: formData
        });
        if (response.ok) {
          const result = await response.json();
          const formatVal = document.getElementById("format").value;
          if (result.data && result.data.length > 0) {
            previewItem.innerHTML = "";
            result.data.forEach((item, idx) => {
              if (item.b64_json) {
                const mime = (formatVal === "jpeg" || formatVal === "webp") ? formatVal : "png";
                const imageSrc = "data:image/" + mime + ";base64," + item.b64_json;
                const img = document.createElement("img");
                img.className = "full-width";
                img.src = imageSrc;
                const caption = document.createElement("p");
                caption.textContent = prompt + (result.data.length > 1 ? ` [${idx + 1}]` : "");
                previewItem.appendChild(caption);
                previewItem.appendChild(img);
              }
            });
            if (previewItem.innerHTML === "") {
              previewItem.textContent = "è¿”å›æ•°æ®ä¸­æ— å›¾ç‰‡æ•°æ®";
            }
          } else {
            previewItem.textContent = "è¿”å›æ•°æ®ä¸­æ— å›¾ç‰‡æ•°æ®";
          }
        } else {
          const errorText = await response.text();
          console.error("è¯¦ç»†é”™è¯¯ä¿¡æ¯ï¼š", errorText);
          previewItem.textContent = "è¯·æ±‚å¤±è´¥ï¼ŒçŠ¶æ€ç ï¼š" + response.status + "ï¼Œè¯¦ç»†ï¼š" + errorText;
        }
      } catch (error) {
        console.error("è¯·æ±‚é”™è¯¯è¯¦æƒ…ï¼š", error);
        previewItem.textContent = "è¯·æ±‚å‡ºç°é”™è¯¯ï¼š" + error;
      } finally {
        const editBtn = document.getElementById("editBtn");
        editBtn.disabled = false;
        editBtn.classList.remove('disabled');
      }
    });

    // æ–°å¢ï¼šé®ç½©ç»˜åˆ¶æŒ‰é’®å¯ç”¨æ€§
    const drawMaskBtn = document.getElementById("drawMaskBtn");
    const maskUploadGroup = document.getElementById("maskUploadGroup");
    const maskCanvasContainer = document.getElementById("maskCanvasContainer");
    const maskToolbox = document.getElementById("maskToolbox");
    const downloadMaskBtn = document.getElementById("downloadMaskBtn");
    const firstInputImage = document.getElementById("firstInputImage");
    const multiInputImage = document.getElementById("multiInputImage");
    let maskCanvas = null;
    let maskCtx = null;
    let drawing = false;
    let brushShape = 'circle';
    // é»˜è®¤ç”»ç¬”å¤§å°
    let brushSize = 30; // ç›´å¾„/è¾¹é•¿
    let maskImageData = null;
    let maskBaseImage = null;
    let isDrawingMask = false;
    let maskCursorOverlay = null;

    function getMaskTargetFile() {
      // ä¼˜å…ˆä½¿ç”¨firstInputImageï¼Œå¦åˆ™multiInputImageçš„ç¬¬ä¸€å¼ 
      if (firstInputImage.files && firstInputImage.files.length > 0) {
        return firstInputImage.files[0];
      } else if (multiInputImage.files && multiInputImage.files.length > 0) {
        return multiInputImage.files[0];
      } else {
        return null;
      }
    }

    // ç”»ç¬”å¤§å°è°ƒèŠ‚äº‹ä»¶ç›‘å¬
    const brushSizeInput = document.getElementById('maskBrushSize');
    const brushSizeVal = document.getElementById('maskBrushSizeVal');
    if (brushSizeInput && brushSizeVal) {
      brushSizeInput.addEventListener('input', function () {
        brushSize = parseInt(brushSizeInput.value, 10);
        brushSizeVal.textContent = brushSize;
      });
    }

    function exitDrawMaskMode() {
      isDrawingMask = false;
      drawMaskBtn.textContent = 'ç»˜åˆ¶é®ç½©';
      maskUploadGroup.classList.remove("hidden");
      maskCanvasContainer.classList.add("hidden");
      maskToolbox.classList.add("hidden");
      downloadMaskBtn.classList.add("hidden");
      if (maskCanvasContainer.firstChild) maskCanvasContainer.removeChild(maskCanvasContainer.firstChild);
      maskCanvas = null;
      maskCtx = null;
      maskImageData = null;
      maskBaseImage = null;
    }
    // ç›‘å¬è¾“å…¥å›¾ç‰‡å˜åŒ–ï¼Œå†³å®šç»˜åˆ¶é®ç½©æŒ‰é’®å¯ç”¨æ€§ï¼Œå¹¶åœ¨å›¾ç‰‡è¢«ç§»é™¤æ—¶é€€å‡ºç»˜åˆ¶æ¨¡å¼
    function updateDrawMaskBtnState() {
      if (getMaskTargetFile()) {
        drawMaskBtn.classList.remove('disabled');
      } else {
        drawMaskBtn.classList.add('disabled');
        if (isDrawingMask) {
          exitDrawMaskMode();
        }
      }
    }
    firstInputImage.addEventListener('change', updateDrawMaskBtnState);
    multiInputImage.addEventListener('change', updateDrawMaskBtnState);

    // ç»˜åˆ¶é®ç½©æŒ‰é’®é€»è¾‘
    drawMaskBtn.addEventListener('click', async () => {
      if (!isDrawingMask) {
        // è¿›å…¥ç»˜åˆ¶æ¨¡å¼
        isDrawingMask = true;
        drawMaskBtn.textContent = 'æ”¾å¼ƒç»˜åˆ¶';
        maskUploadGroup.classList.add("hidden");
        maskCanvasContainer.classList.remove("hidden");
        maskToolbox.classList.remove("hidden");
        downloadMaskBtn.classList.remove("hidden");
        // åˆå§‹åŒ–ç”»å¸ƒ
        await setupMaskCanvas();
      } else {
        // é€€å‡ºç»˜åˆ¶æ¨¡å¼
        exitDrawMaskMode();
      }
    });

    // åˆå§‹åŒ–é®ç½©ç”»å¸ƒ
    async function setupMaskCanvas() {
      // æ¸…ç©ºå®¹å™¨
      maskCanvasContainer.innerHTML = '';
      maskCanvas = document.createElement('canvas');
      maskCanvas.style.border = '1px solid #ccc';
      maskCanvas.style.display = 'block';
      maskCanvas.style.position = 'relative';
      maskCanvasContainer.appendChild(maskCanvas);
      // æ˜ç¡®ä½¿ç”¨firstInputImageæˆ–multiInputImageçš„ç¬¬ä¸€å¼ 
      const file = getMaskTargetFile();
      if (!file) {
        alert("è¯·å…ˆä¸Šä¼ å›¾ç‰‡ï¼");
        exitDrawMaskMode();
        return;
      }
      const img = new window.Image();
      img.src = await fileToDataURL(file);
      await new Promise(res => { img.onload = res; });
      maskBaseImage = img;
      
      // è®¡ç®—ç»˜åˆ¶ç”»å¸ƒå°ºå¯¸ (æœ€å¤§é«˜åº¦768ï¼Œæœ€å¤§å®½åº¦1532)
      let drawWidth = img.width, drawHeight = img.height;
      if (img.height > 768 || img.width > 1532) {
        const scale = Math.min(768 / img.height, 1532 / img.width);
        drawWidth = Math.round(img.width * scale);
        drawHeight = Math.round(img.height * scale);
      }
      
      // è®¾ç½®ç”»å¸ƒå®é™…å°ºå¯¸ä¸ºç»˜åˆ¶å°ºå¯¸
      maskCanvas.width = drawWidth;
      maskCanvas.height = drawHeight;
      // æ˜¾ç¤ºå°ºå¯¸ä¸ç»˜åˆ¶å°ºå¯¸ç›¸åŒ
      maskCanvas.style.width = drawWidth + 'px';
      maskCanvas.style.height = drawHeight + 'px';
      maskCtx = maskCanvas.getContext('2d');
      // æ–°å»ºé®ç½©å±‚ï¼ˆå…¨ä¸é€æ˜ï¼‰- ä½¿ç”¨ç»˜åˆ¶å°ºå¯¸è€ŒéåŸå›¾å°ºå¯¸
      maskImageData = maskCtx.createImageData(drawWidth, drawHeight);
      for (let i = 0; i < maskImageData.data.length; i += 4) {
        maskImageData.data[i + 3] = 255; // alpha=255
      }
      // åŠ¨æ€è®¾ç½®ç”»ç¬”æœ€å¤§å€¼ä¸ºç¼©æ”¾åå›¾ç‰‡é•¿è¾¹çš„1.1å€
      const scaledMaxDimension = Math.max(img.width, img.height); // è·å–ç¼©æ”¾åçš„é•¿è¾¹
      const maxBrushSize = Math.round(scaledMaxDimension * 1.1);
      const brushSizeInput = document.getElementById('maskBrushSize');
      brushSizeInput.max = maxBrushSize;
      // è‹¥å½“å‰brushSizeè¶…å‡ºæœ€å¤§å€¼ï¼Œé‡ç½®
      if (brushSize > maxBrushSize) {
        brushSize = maxBrushSize;
        brushSizeInput.value = brushSize;
        document.getElementById('maskBrushSizeVal').textContent = brushSize;
      } else {
        // åŒæ­¥æ˜¾ç¤º
        brushSizeInput.value = brushSize;
        document.getElementById('maskBrushSizeVal').textContent = brushSize;
      }
      // é¢„è§ˆå…‰æ ‡canvasï¼ˆå…¨å±€å”¯ä¸€ï¼‰
      if (!maskCursorOverlay) {
        maskCursorOverlay = document.createElement('canvas');
        maskCursorOverlay.style.position = 'absolute';
        maskCursorOverlay.style.left = '0';
        maskCursorOverlay.style.top = '0';
        maskCursorOverlay.style.pointerEvents = 'none';
        maskCanvasContainer.appendChild(maskCursorOverlay);
      } else {
        maskCanvasContainer.appendChild(maskCursorOverlay);
      }
      maskCursorOverlay.width = maskCanvas.width;
      maskCursorOverlay.height = maskCanvas.height;
      maskCursorOverlay.style.width = maskCanvas.style.width;
      maskCursorOverlay.style.height = maskCanvas.style.height;
      // ç”»å¸ƒäº‹ä»¶
      maskCanvas.onmousedown = e => { drawing = true; lastDrawX = lastDrawY = null; drawAt(e); };
      maskCanvas.onmouseup = () => { drawing = false; lastDrawX = lastDrawY = null; };
      maskCanvas.onmouseleave = () => { drawing = false; lastDrawX = lastDrawY = null; maskCursorOverlay.classList.add('hidden'); };
      maskCanvas.onmousemove = e => {
        if (drawing) drawAt(e);
        drawCursorOverlay(e);
      };
      maskCanvas.onmouseenter = e => { maskCursorOverlay.classList.remove('hidden'); drawCursorOverlay(e); };
      // è§¦æ‘¸æ”¯æŒï¼ˆä¸æ˜¾ç¤ºé¢„è§ˆï¼‰
      maskCanvas.ontouchstart = e => { drawing = true; lastDrawX = lastDrawY = null; drawAt(e.touches[0]); e.preventDefault(); maskCursorOverlay.classList.add('hidden'); };
      maskCanvas.ontouchend = () => { drawing = false; lastDrawX = lastDrawY = null; };
      maskCanvas.ontouchcancel = () => { drawing = false; lastDrawX = lastDrawY = null; };
      maskCanvas.ontouchmove = e => { if (drawing) drawAt(e.touches[0]); e.preventDefault(); maskCursorOverlay.classList.add('hidden'); };
      // é¢„è§ˆå…‰æ ‡ç»˜åˆ¶å‡½æ•°
      function drawCursorOverlay(e) {
        const rect = maskCanvas.getBoundingClientRect();
        const x = Math.round((e.clientX - rect.left) * maskCanvas.width / rect.width);
        const y = Math.round((e.clientY - rect.top) * maskCanvas.height / rect.height);
        const ctx = maskCursorOverlay.getContext('2d');
        ctx.clearRect(0, 0, maskCursorOverlay.width, maskCursorOverlay.height);
        ctx.save();
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#fff';
        ctx.shadowColor = '#000';
        ctx.shadowBlur = 0;
        ctx.beginPath();
        const half = brushSize / 2;
        if (brushShape === 'circle') {
          ctx.arc(x, y, half, 0, 2 * Math.PI);
        } else {
          ctx.rect(x - half, y - half, brushSize, brushSize);
        }
        ctx.stroke();
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#000';
        ctx.shadowColor = 'transparent';
        ctx.beginPath();
        if (brushShape === 'circle') {
          ctx.arc(x, y, half, 0, 2 * Math.PI);
        } else {
          ctx.rect(x - half, y - half, brushSize, brushSize);
        }
        ctx.stroke();
        ctx.restore();
      }
      // åˆå§‹æ¸²æŸ“
      renderMaskCanvas();
    }
    function renderMaskCanvas() {
      // å…ˆç”»åº•å›¾
      maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
      maskCtx.drawImage(maskBaseImage, 0, 0, maskCanvas.width, maskCanvas.height);
      // ç”¨ç¦»å±canvasç”Ÿæˆçº¢è‰²é®ç½©å±‚
      const maskVisCanvas = document.createElement('canvas');
      maskVisCanvas.width = maskImageData.width;
      maskVisCanvas.height = maskImageData.height;
      const visCtx = maskVisCanvas.getContext('2d');
      const visImg = visCtx.createImageData(maskImageData.width, maskImageData.height);
      for (let i = 0; i < maskImageData.data.length; i += 4) {
        if (maskImageData.data[i + 3] === 0) {
          visImg.data[i] = 255; visImg.data[i + 1] = 0; visImg.data[i + 2] = 0; visImg.data[i + 3] = 180; // çº¢è‰²æ›´æ˜æ˜¾
        } else {
          visImg.data[i + 3] = 0;
        }
      }
      visCtx.putImageData(visImg, 0, 0);
      maskCtx.drawImage(maskVisCanvas, 0, 0, maskCanvas.width, maskCanvas.height);
    }
    // ä¸‹è½½é®ç½©
    downloadMaskBtn.addEventListener('click', () => {
      if (!maskCanvas || !maskImageData) return;
      // åˆ›å»ºåŸå›¾å°ºå¯¸çš„å¯¼å‡ºç”»å¸ƒ
      const exportCanvas = document.createElement('canvas');
      exportCanvas.width = maskBaseImage.width;
      exportCanvas.height = maskBaseImage.height;
      const exportCtx = exportCanvas.getContext('2d');
      
      // å…ˆå°†é®ç½©ç»˜åˆ¶åˆ°ä¸´æ—¶ç”»å¸ƒ
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = maskImageData.width;
      tempCanvas.height = maskImageData.height;
      const tempCtx = tempCanvas.getContext('2d');
      const tempImgData = tempCtx.createImageData(maskImageData.width, maskImageData.height);
      for (let i = 0; i < maskImageData.data.length; i += 4) {
        tempImgData.data[i] = 0;
        tempImgData.data[i + 1] = 0;
        tempImgData.data[i + 2] = 0;
        tempImgData.data[i + 3] = 255 - maskImageData.data[i + 3];
      }
      tempCtx.putImageData(tempImgData, 0, 0);
      
      // å°†ä¸´æ—¶ç”»å¸ƒæ‹‰ä¼¸åˆ°åŸå›¾å°ºå¯¸
      exportCtx.drawImage(tempCanvas, 0, 0, maskBaseImage.width, maskBaseImage.height);
      exportCanvas.toBlob(blob => {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'mask.png';
        a.click();
      }, 'image/png');
    });
    // é€€å‡ºç»˜åˆ¶æ¨¡å¼æ—¶ï¼Œæ¢å¤é®ç½©ä¸Šä¼ 
    document.getElementById("maskImage").addEventListener('change', () => {
      if (isDrawingMask) {
        exitDrawMaskMode();
      }
    });
  </script>
</body>

</html>